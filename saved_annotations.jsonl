{"task_id": "00576224", "split": "training", "test_index": 0, "output": [[3, 2, 3, 2, 3, 2], [7, 8, 7, 8, 7, 8], [2, 3, 2, 3, 2, 3], [8, 7, 8, 7, 8, 7], [3, 2, 3, 2, 3, 2], [7, 8, 7, 8, 7, 8]], "output_hash": "bd167af0", "output_sha1": "452b947f78224ba20aec174c90acecb789fc7b24", "ok": true, "insts": ["1) Create a 6 by 6 grid.\n2) Receive an input 2 by 2 pattern (the base pattern). Ensure it is exactly 2 by 2.\n3) Create a vertically reflected variant of the base pattern by swapping its left and right columns.\n4) Partition the 6 by 6 grid into a 3 by 3 arrangement of 2 by 2 tiles.\n5) In the top tile row (tiles covering grid rows 1–2): place the base pattern repeated across all three tile positions.\n6) In the middle tile row (tiles covering grid rows 3–4): place the vertically reflected pattern repeated across all three tile positions.\n7) In the bottom tile row (tiles covering grid rows 5–6): place the base pattern repeated across all three tile positions.\n8) Ensure patterns in each tile align edge-to-edge without gaps or overlaps so the 6 by 6 grid is fully covered."], "insts_text": "1) Create a 6 by 6 grid.\n2) Receive an input 2 by 2 pattern (the base pattern). Ensure it is exactly 2 by 2.\n3) Create a vertically reflected variant of the base pattern by swapping its left and right columns.\n4) Partition the 6 by 6 grid into a 3 by 3 arrangement of 2 by 2 tiles.\n5) In the top tile row (tiles covering grid rows 1–2): place the base pattern repeated across all three tile positions.\n6) In the middle tile row (tiles covering grid rows 3–4): place the vertically reflected pattern repeated across all three tile positions.\n7) In the bottom tile row (tiles covering grid rows 5–6): place the base pattern repeated across all three tile positions.\n8) Ensure patterns in each tile align edge-to-edge without gaps or overlaps so the 6 by 6 grid is fully covered.", "nlp_program": "1) Define a 6-by-6 grid with row indices 1–6 and column indices 1–6; all cells are initially unspecified.\n2) Receive an input base pattern of size exactly 2-by-2. Validate that it has exactly 2 rows and 2 columns; if not, reject the input and request a valid 2-by-2 pattern.\n3) Name the base pattern P, with entries P[r,c] where r ∈ {1,2} and c ∈ {1,2}.\n4) Create a vertically reflected variant V of P by swapping its left and right columns: for each r ∈ {1,2}, set V[r,1] = P[r,2] and V[r,2] = P[r,1}.\n5) Partition the 6-by-6 grid into a 3-by-3 arrangement of non-overlapping 2-by-2 tiles. Define tile T[i,j] for tile row i ∈ {1,2,3} and tile column j ∈ {1,2,3} to cover grid rows (2i−1, 2i) and grid columns (2j−1, 2j).\n6) Specify the pattern assignment for each tile row:\n   - For tile row i = 1 (grid rows 1–2): assign the base pattern P to all three tiles T[1,1], T[1,2], T[1,3].\n   - For tile row i = 2 (grid rows 3–4): assign the vertically reflected pattern V to all three tiles T[2,1], T[2,2], T[2,3].\n   - For tile row i = 3 (grid rows 5–6): assign the base pattern P to all three tiles T[3,1], T[3,2], T[3,3].\n7) Place each assigned pattern into its tile with consistent local-to-global indexing: for every tile T[i,j] and for every local cell (u,v) where u ∈ {1,2} and v ∈ {1,2}, write the value of the assigned pattern at (u,v) into the global grid cell at row r = 2i − 2 + u and column c = 2j − 2 + v.\n8) Ensure that all grid cells (rows 1–6, columns 1–6) are filled exactly once, with no gaps and no overlaps between tiles.\n9) Produce the completed 6-by-6 grid as the result.", "variations": ["1) Initialize a 6 by 6 grid.\n2) Receive a 2 by 2 base pattern and verify it is exactly 2 by 2.\n3) Construct a 2 by 6 strip by repeating the base pattern horizontally three times without gaps.\n4) Construct a vertically reflected version of the base pattern by swapping its left and right columns, then form a 2 by 6 strip by repeating it horizontally three times.\n5) Stack three strips to form the 6 by 6 grid: top strip = base strip, middle strip = reflected strip, bottom strip = base strip.\n6) Ensure all strips and their constituent patterns meet edge-to-edge with no overlaps or gaps, fully covering the 6 by 6 grid.", "1) Set up a blank 6 by 6 grid.\n2) Accept a base pattern that must be 2 by 2; reject any other size.\n3) Produce a vertically mirrored variant of the base pattern by exchanging its left and right columns.\n4) Divide the grid into nine tiles arranged as 3 columns by 3 rows, each tile being 2 by 2.\n5) For each tile row r in {1,2,3} and tile column c in {1,2,3}:\n   - If r = 2, place the mirrored pattern in tile (r,c).\n   - Otherwise, place the base pattern in tile (r,c).\n6) Confirm that tiles abut perfectly so that the 6 by 6 grid is completely filled.", "1) Create a 6 by 6 canvas.\n2) Take an input base pattern and confirm it is a 2 by 2 matrix.\n3) Derive a column-flipped version of the base pattern by swapping its left and right columns.\n4) Fill the entire 6 by 6 canvas initially by tiling the base pattern across all nine 2 by 2 tiles (3 across by 3 down).\n5) Replace the three tiles that occupy rows 3–4 of the canvas (the middle tile row) with the column-flipped version of the pattern, applied in each of those three tiles.\n6) Verify that all tile boundaries align exactly, with no gaps or overlaps, resulting in full coverage of the 6 by 6 canvas."], "llm_error": null, "all_test_hashes": ["bd167af0"], "timestamp": 1758189378.239441}
{"task_id": "007bbfb7", "split": "training", "test_index": 0, "output": [[7, 0, 7, 0, 0, 0, 7, 0, 7], [7, 0, 7, 0, 0, 0, 7, 0, 7], [7, 7, 0, 0, 0, 0, 7, 7, 0], [7, 0, 7, 0, 0, 0, 7, 0, 7], [7, 0, 7, 0, 0, 0, 7, 0, 7], [7, 7, 0, 0, 0, 0, 7, 7, 0], [7, 0, 7, 7, 0, 7, 0, 0, 0], [7, 0, 7, 7, 0, 7, 0, 0, 0], [7, 7, 0, 7, 7, 0, 0, 0, 0]], "output_hash": "7209306c", "output_sha1": "9031a83092cff9aaddd1dc086194717c30d39a55", "ok": true, "insts": ["1) The input grids seem to be 3 by 3, the output 9 *9, so map 3 * 3 => 9 * 9\n2) Create a 9 by 9 output grid\n3) Each 3 by 3 block in the output grid corresponds to 1 block in the 3 by 3 input grid, arranged by position\n4) If the input block is colored then copy the input pattern into the 3 * 3 corresponding pattern in the output, if not leave with color zero"], "insts_text": "1) The input grids seem to be 3 by 3, the output 9 *9, so map 3 * 3 => 9 * 9\n2) Create a 9 by 9 output grid\n3) Each 3 by 3 block in the output grid corresponds to 1 block in the 3 by 3 input grid, arranged by position\n4) If the input block is colored then copy the input pattern into the 3 * 3 corresponding pattern in the output, if not leave with color zero", "nlp_program": "1) Take a 3 by 3 input grid where color 0 represents empty and non-zero colors represent filled cells\n2) Create a 9 by 9 output grid initialized to color 0\n3) Partition the 9 by 9 output grid into nine non-overlapping 3 by 3 blocks arranged in a 3 by 3 layout matching the positions of the input cells\n4) For each position (row, column) in the 3 by 3 input grid:\n   a) If the input cell at that position is color 0, leave the corresponding 3 by 3 output block as color 0\n   b) If the input cell at that position has a non-zero color, fill the corresponding 3 by 3 output block with a copy of the entire 3 by 3 input pattern, preserving all colors and their relative positions\n5) Leave all other cells of the output grid unchanged from their assigned values in the steps above", "variations": ["1) Recognize the input as a 3 by 3 grid and define the output as 9 by 9\n2) Partition the 9 by 9 canvas into nine 3 by 3 blocks mirroring the input positions\n3) For each input cell, if it is zero, leave its corresponding 3 by 3 block all zeros\n4) If an input cell is colored, stamp a full copy of the entire 3 by 3 input pattern into the matching 3 by 3 block in the output", "1) Build a 9 by 9 result initialized to color zero\n2) Treat the input as a mask over positions (row, col) in a 3 by 3 layout\n3) For every position where the input has a nonzero color, paste the whole 3 by 3 input pattern into the 3 by 3 block of the output aligned to that position\n4) Leave blocks corresponding to zero-valued input cells as zeros", "1) Consider each input cell as selecting whether to place or skip a pattern tile\n2) Tile the output as a 3 by 3 grid of tiles, each tile being 3 by 3 cells\n3) For each tile position, if the corresponding input cell is zero, keep the tile all zeros\n4) If the corresponding input cell is colored, fill that tile by copying the entire input 3 by 3 pattern into it"], "llm_error": null, "all_test_hashes": ["7209306c"], "timestamp": 1758190136.5232441}
{"task_id": "009d5c81", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [0, 0, 0, 0, 0, 7, 0, 0, 0, 7, 0, 7, 0, 7], [0, 0, 0, 0, 0, 7, 0, 7, 0, 7, 0, 0, 0, 7], [0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output_hash": "80271ef2", "output_sha1": "9bec0b1fd4c729db32db598dc2bf25be782ade0d", "ok": true, "insts": ["1) The input output shapes are the same \n2) In each input there is a large object and a small object. \n3) Copy the input objs into the output\n4) If the small object is a cross then the large object should be colored with color 2. If the small object looks like a X but with the bottom row fully colored with black( a 3 by 3  X), then thr large object should be colored no 3. If the small obj is liek a open square but with the bottom row missing the two left and right edges then the large obj should be colored 7. \n4) Only the large obj should changed color in the final output, the small obj should not be there in the output."], "insts_text": "1) The input output shapes are the same \n2) In each input there is a large object and a small object. \n3) Copy the input objs into the output\n4) If the small object is a cross then the large object should be colored with color 2. If the small object looks like a X but with the bottom row fully colored with black( a 3 by 3  X), then thr large object should be colored no 3. If the small obj is liek a open square but with the bottom row missing the two left and right edges then the large obj should be colored 7. \n4) Only the large obj should changed color in the final output, the small obj should not be there in the output.", "nlp_program": "1) Set the output grid to have the same dimensions as the input grid.\n2) Identify all connected objects in the input grid.\n3) Classify the two objects by size (number of occupied cells): the larger object is the large object; the smaller object is the small object.\n4) Determine the type of the small object using these shape criteria:\n   4.1) Cross: a plus-shaped object with one central cell and four arms of equal length aligned to the four orthogonal directions; no diagonal cells are part of the object.\n   4.2) Modified X (3x3 X with a full bottom row): within a 3x3 bounding box, cells on the two diagonals are filled, and all three cells of the bottom row are also filled.\n   4.3) Open square with bottom row missing corners: a U-shaped object where the left column and right column are filled from top to bottom, the top row is filled across, and on the bottom row only the middle cell is filled (the bottom-left and bottom-right corner cells are empty).\n5) Set the target color for the large object based on the small object type:\n   5.1) If the small object is a Cross, target color = 2.\n   5.2) If the small object is the Modified X (as defined in 4.2), target color = 3.\n   5.3) If the small object is the Open square variant (as defined in 4.3), target color = 7.\n6) Construct the output grid as follows:\n   6.1) Place the large object in the same position and with the same shape as in the input.\n   6.2) Recolor all cells of the large object to the target color determined in step 5.\n   6.3) Do not place the small object in the output; no cells of the small object appear in the final grid.\n7) Leave all other cells not belonging to the large object as background (unchanged from background color).", "variations": ["1) Keep the output grid the same size as the input\n2) Find all connected components and label the larger one as the big object and the smaller one as the small object\n3) Inspect the small object’s structure: if it has a central cell with four orthogonal arms (a plus/cross), tag it as type A; if it is a 3x3 pattern with both diagonals filled and the entire bottom row filled, tag it as type B; if it is an open square frame where the bottom edge only keeps the middle cell and the two bottom corners are missing, tag it as type C\n4) Map types to colors: A -> color 2, B -> color 3, C -> color 7\n5) Recolor every cell of the large object to the mapped color\n6) Remove the small object entirely so only the recolored large object remains", "1) Preserve the input canvas dimensions in the output\n2) Copy the scene, then distinguish objects by area and perimeter: the one with the greater area is the large object; the other is the small cue\n3) Match the small cue to one of three templates regardless of its original color: template Plus (cross with arms up/down/left/right), template Diagonal-X-3x3-with-solid-bottom-row, template Open-Box with bottom corners absent and only the bottom middle present\n4) Use a lookup to decide the target color of the large object: Plus -> 2, Diagonal-X-with-solid-bottom -> 3, Open-Box-missing-bottom-corners -> 7\n5) Flood-repaint the large object to the chosen color\n6) Erase the small cue so it does not appear in the output", "1) Do not change the grid size between input and output\n2) Segment the image into two components and pick the one with the larger bounding box as the large object; the other is the small marker\n3) Classify the small marker by connectivity and edge presence: cross = orthogonal arms from a center; 3x3 X with both diagonals plus a fully filled bottom row; hollow square frame with the bottom left and bottom right corner cells missing\n4) Assign the large object’s new color based on the marker class: cross -> 2, X-with-full-bottom -> 3, open frame with missing bottom corners -> 7\n5) Paint the large object uniformly with the assigned color\n6) Remove the small marker so only the recolored large object remains in the output"], "llm_error": null, "all_test_hashes": ["80271ef2"], "timestamp": 1758190627.4339776}
{"task_id": "00d62c1b", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 4, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 0, 3, 3, 3, 3, 3, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 4, 4, 4, 4, 3, 4, 4, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 4, 4, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 4, 4, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 4, 4, 4, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 4, 4, 3, 4, 4, 4, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 0, 0], [0, 0, 0, 0, 0, 0, 3, 3, 4, 3, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 4, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 0, 3, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 4, 4, 4, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 4, 4, 4, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output_hash": "6a8c281a", "output_sha1": "e1eaf209c5a61be2c4b406976eacc2b8cbec1c1e", "ok": true, "insts": ["1)Start with an output grid that is a copy of the input grid.\n\n2)Use 4-connectivity for neighbors (up, down, left, right only).\n\n3)Define the boundary as all cells in the first/last row and first/last column.\n\n4)Mark escapable zero-valued cells:\n4.1) All zero cells on the boundary are escapable.\n4.2) Any zero cell connected (by 4-neighbors) to an escapable cell is also escapable.\n\n5)Group all zero-valued cells into 4-connected regions.\n\n6)For each zero-valued region:\n6.1) If it contains an escapable cell → classify as non-enclosed.\n6.2) If it has no escapable cells → classify as enclosed.\n\n7)For every enclosed region, change all its cells to color 4 in the output grid.\n\n8)Leave all non-zero cells unchanged.\n\n9)Output the final grid."], "insts_text": "1)Start with an output grid that is a copy of the input grid.\n\n2)Use 4-connectivity for neighbors (up, down, left, right only).\n\n3)Define the boundary as all cells in the first/last row and first/last column.\n\n4)Mark escapable zero-valued cells:\n4.1) All zero cells on the boundary are escapable.\n4.2) Any zero cell connected (by 4-neighbors) to an escapable cell is also escapable.\n\n5)Group all zero-valued cells into 4-connected regions.\n\n6)For each zero-valued region:\n6.1) If it contains an escapable cell → classify as non-enclosed.\n6.2) If it has no escapable cells → classify as enclosed.\n\n7)For every enclosed region, change all its cells to color 4 in the output grid.\n\n8)Leave all non-zero cells unchanged.\n\n9)Output the final grid.", "nlp_program": "1) Create an output grid identical to the input grid.\n2) Use 4-connectivity to define adjacency (each cell has up to four neighbors: up, down, left, right).\n3) Define the boundary set as all cells in the first row, last row, first column, and last column of the grid.\n4) Identify escapable zero-valued cells:\n   4.1) Mark all zero-valued cells in the boundary set as escapable.\n   4.2) Repeatedly mark any zero-valued cell as escapable if it is 4-connected to an already marked escapable cell.\n5) Partition all zero-valued cells into 4-connected regions (each region is a maximal set of zero-valued cells connected by 4-connectivity).\n6) Classify each zero-valued region:\n   6.1) If the region contains at least one escapable cell, classify the region as non-enclosed.\n   6.2) If the region contains no escapable cells, classify the region as enclosed.\n7) For every enclosed region, set all cells of that region in the output grid to color 4.\n8) Leave all non-zero cells and all zero-valued cells in non-enclosed regions unchanged in the output grid.\n9) Return the output grid.", "variations": ["1) Initialize the output grid as a copy of the input.\n\n2) Create a label map for zero-valued cells using 4-connectivity (union-find or any consistent labeling method).\n\n3) For each labeled zero region, record whether any of its cells lies on the boundary (first/last row or column).\n\n4) For every zero region that does not touch the boundary, recolor all its cells to color 4 in the output grid.\n\n5) Leave all non-zero cells unchanged.\n\n6) Return the output grid.", "1) Copy the input grid to the output.\n\n2) Conceptually add a one-cell-wide frame of non-zero values around the grid (virtual padding) to define an outside.\n\n3) From the padded boundary, perform a 4-connected flood over zero-valued cells inside the original grid, marking all zeros that are reachable from the outside.\n\n4) Any zero cell not marked as reachable is enclosed; set those cells to color 4 in the output grid.\n\n5) Do not alter non-zero cells.\n\n6) Produce the final output grid.", "1) Start with the output grid equal to the input grid.\n\n2) Mark all boundary zero cells as outside and place them in a queue.\n\n3) Repeatedly process the queue: for each marked cell, mark any 4-neighbor zero cell as outside and enqueue it. Continue until no new cells are marked.\n\n4) After propagation, any zero cell not marked as outside belongs to an enclosed region; change those cells to color 4 in the output grid.\n\n5) Keep all non-zero cells unchanged.\n\n6) Output the result."], "llm_error": null, "all_test_hashes": ["6a8c281a"], "timestamp": 1758191250.3982446}
{"task_id": "00dbd492", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 8, 8, 8, 2, 0, 0, 0, 0], [0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 2, 8, 2, 8, 2, 0, 0, 0, 0], [0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 2, 8, 8, 8, 2, 0, 0, 0, 0], [0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 2, 3, 3, 3, 2, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0], [0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 0, 2, 8, 8, 8, 2, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 2, 8, 2, 8, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 8, 8, 8, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 4, 4, 4, 4, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 4, 4, 4, 4, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 4, 4, 2, 4, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 4, 4, 4, 4, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 4, 4, 4, 4, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output_hash": "fd34de94", "output_sha1": "b76a038e9becfd62947701d89ef5bd17bff8c780", "ok": true, "insts": ["1) Set the output grid to be an exact copy of the input grid.\n2) You might will see 1 or more square shape(with a  dot in the middle(leave the dot)\n3) If the square is 9 * 9 fill with color 3. If the square is 7 * 7 fill with color 4 and if it is 5 * 5 fill with color 8. Leave the dot however. \n4) Return this grid."], "insts_text": "1) Set the output grid to be an exact copy of the input grid.\n2) You might will see 1 or more square shape(with a  dot in the middle(leave the dot)\n3) If the square is 9 * 9 fill with color 3. If the square is 7 * 7 fill with color 4 and if it is 5 * 5 fill with color 8. Leave the dot however. \n4) Return this grid.", "nlp_program": "1) Initialize the output grid as an exact copy of the input grid.\n2) Identify all axis-aligned square regions present in the input grid that each contain a single dot cell located at the exact geometric center of the square. Squares of interest have side lengths of 9, 7, or 5 cells. Assume squares do not overlap.\n3) For each identified square:\n   a) Determine its side length (9, 7, or 5).\n   b) Determine the target fill color based on side length:\n      - 9×9 square → color 3\n      - 7×7 square → color 4\n      - 5×5 square → color 8\n   c) Recolor every cell within the square’s bounding box in the output grid to the target fill color, except the central dot cell, which must remain unchanged.\n4) Leave all cells outside these squares unchanged from the input grid.\n5) Return the output grid.", "variations": ["1) Begin with the input grid as the working grid.\n2) Identify every square region that has a single center dot; do not modify the dot.\n3) If the square’s side is 9, recolor the square area with color 3; if 7, use color 4; if 5, use color 8. Always leave the center dot unchanged.\n4) Output the resulting grid.", "1) Copy the input grid to the output unchanged initially.\n2) For each cell that is a dot, expand equally up, down, left, and right to detect a surrounding square; valid sizes are 5, 7, or 9 with the dot at the exact center.\n3) Upon finding a valid square, fill its entire area with the mapped color (5→8, 7→4, 9→3), skipping the center dot so it remains as is.\n4) Return the updated grid.", "1) Use the input grid as the output baseline.\n2) Scan for square-shaped regions; each valid region must have odd side length and a dot at its center.\n3) Apply color based on size: 9×9 to color 3, 7×7 to color 4, 5×5 to color 8, while preserving the center dot cell in every case.\n4) Produce the final grid."], "llm_error": null, "all_test_hashes": ["fd34de94"], "timestamp": 1758191950.4518142}
{"task_id": "017c7c7b", "split": "training", "test_index": 0, "output": [[2, 2, 2], [0, 2, 0], [0, 2, 0], [2, 2, 2], [0, 2, 0], [0, 2, 0], [2, 2, 2], [0, 2, 0], [0, 2, 0]], "output_hash": "cf706036", "output_sha1": "79093563eaac9989832dab7f7f260924771ca48d", "ok": true, "insts": ["1) Copy input to rows 1-6 of 9x3 grid\n2) For each column: identify the repeating pattern length\n3) Continue the pattern for 3 more rows\n4) Replace 1 with 2"], "insts_text": "1) Copy input to rows 1-6 of 9x3 grid\n2) For each column: identify the repeating pattern length\n3) Continue the pattern for 3 more rows\n4) Replace 1 with 2", "nlp_program": "1) Initialize a grid with 9 rows and 3 columns. Index rows 1 through 9 (top to bottom) and columns 1 through 3 (left to right).\n2) Take the provided input data comprising 6 rows and 3 columns and copy it into rows 1 through 6 of the grid, preserving column alignment.\n3) For each column independently, analyze the sequence formed by its values in rows 1 through 6 to determine a repeating pattern length:\n   a) Identify the smallest positive period p (1 ≤ p ≤ 6) such that the sequence in rows 1 through 6 can be generated by repeating the first p values up to row 6.\n   b) If no period shorter than 6 satisfies this condition, set the pattern length to 6.\n4) For each column, define its repeating pattern as the first p values of that column, where p is the pattern length determined in step 3 for that column.\n5) For each column, extend its values to rows 7 through 9 by continuing the repeating pattern cyclically from where row 6 left off.\n6) After all columns have been extended, perform a value replacement across the entire 9x3 grid: replace every occurrence of the value 1 with the value 2.\n7) Leave all other values unchanged.", "variations": ["1) Initialize a 9x3 grid and load the provided entries into rows 1 through 6\n2) For each column, determine the minimal repeating cycle present in those six values\n3) Use that cycle to fill rows 7, 8, and 9 by periodic continuation\n4) After completion, convert every occurrence of 1 into 2", "1) Start with a 9 by 3 layout and copy the input into the first six rows\n2) Treat each column as an independent sequence and infer its shortest repeating period\n3) Extend each column downward to rows 7–9 using modular repetition of the period\n4) Make a final pass replacing all 1s with 2s", "1) Create a 9x3 table and place the input exactly in rows 1–6\n2) Analyze each column to find the smallest period that reproduces the observed pattern\n3) Propagate the detected pattern to populate the remaining three rows\n4) Standardize by swapping every 1 in the grid to 2"], "llm_error": null, "all_test_hashes": ["cf706036"], "timestamp": 1758193497.9295535}
{"task_id": "025d127b", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 4, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 4], [0, 0, 0, 0, 4, 0, 0, 0, 0, 4], [0, 0, 0, 0, 4, 4, 4, 4, 4, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output_hash": "ce3bf684", "output_sha1": "dba155d222e6f2d0a2429e1e608176dea69e6bcb", "ok": true, "insts": ["1) Output grid should be the same as the input grid in shape\n2) From the input grid isolate the shape present, that is not a 0 color. Take the horizontal bottom line and copy this to the output exactly.  Do this for all objects.\n3) For everything above the line move horizontally by 1 block, if you hit a wall stop, if you are already at a wall before moving don't move. Simple shift right for parts oft eh object above the bottom line of the object. \n4) Take this shifted part and also copy into the output and returen"], "insts_text": "1) Output grid should be the same as the input grid in shape\n2) From the input grid isolate the shape present, that is not a 0 color. Take the horizontal bottom line and copy this to the output exactly.  Do this for all objects.\n3) For everything above the line move horizontally by 1 block, if you hit a wall stop, if you are already at a wall before moving don't move. Simple shift right for parts oft eh object above the bottom line of the object. \n4) Take this shifted part and also copy into the output and returen", "nlp_program": "1) Create an output grid with the same dimensions as the input grid, initialized to background (0).\n2) Identify all objects in the input grid as maximal 4-connected sets of non-zero cells. Treat each object independently.\n3) For each object:\n   a) Determine the object’s bottom row index (the maximum row index among the object’s cells).\n   b) Define the object’s bottom line as all cells of the object that lie on this bottom row index. Copy these bottom-line cells to the identical coordinates in the output grid, preserving their colors.\n   c) For all remaining cells of the object (those strictly above the bottom line): attempt to shift each cell exactly one column to the right.\n      - If the cell is already in the rightmost column (wall), do not move it; its target remains its original position.\n      - Otherwise, move it one column to the right (do not move beyond the grid boundary).\n   d) Place these shifted (or unshifted, if blocked by the wall) cells into the output grid at their target coordinates, preserving their colors.\n4) Repeat step 3 for all objects.\n5) Return the output grid.", "variations": ["1) Keep the output grid identical in size to the input\n2) Detect each nonzero-colored object as a connected component\n3) For each object, find its lowest occupied row; copy exactly the cells of the object on that row into the same positions in the output\n4) For every other cell of the object (rows above that lowest row), translate it one column to the right unless that would leave the grid, in which case it stays in place\n5) Write the translated upper cells and the unshifted bottom row to the output for all objects", "1) Preserve the input grid dimensions for the output\n2) For all nonzero cells, build object masks (one mask per object)\n3) From each mask, extract the bottom edge by taking the object cells on the minimal-from-bottom row index of that object and deposit them directly into the output unchanged\n4) Create a second mask of the object’s cells strictly above that bottom row and shift this mask one step to the right, clamping any cells at the right boundary so they do not move past the edge\n5) Composite the shifted upper mask with the unchanged bottom edge into the output for every object", "1) The output must have the same width and height as the input\n2) For each nonzero-colored object, determine its base row (the lowest row in which the object has any cells) and copy those base-row cells into the output as-is\n3) Process the object’s remaining rows above the base: for each such row, move its cells one column to the right unless they are already at the rightmost column, in which case they remain\n4) Place these shifted upper rows together with the unchanged base row into the output, and repeat this for all objects"], "llm_error": null, "all_test_hashes": ["ce3bf684"], "timestamp": 1758194034.4179368}
{"task_id": "03560426", "split": "training", "test_index": 0, "output": [[7, 0, 0, 0, 0, 0, 0, 0, 0, 0], [7, 0, 0, 0, 0, 0, 0, 0, 0, 0], [7, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 6, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output_hash": "11ee81d1", "output_sha1": "738052ee207e8926b86daa3b555aa6674d6dccc1", "ok": true, "insts": ["1) The input will have objects of different non zero colors. \n2) Create an output grid of 0s of the same size. \n3) Take the leftmost obj and copy and align to the left topmost part of the output grid. Then take the second leftmost obj in the input. and align it in the output to the bottom rightmost block of the previously placed object, do the same for the third obj excpet place it at the rightmost bottom of the previous 2nd obj\n4) Repeat until all objects have been place, not the anchor is at the rightmost colored block of the previously placed block, that block, the newly placed block will overlap the old block if there is any overlap color that block with the newest one."], "insts_text": "1) The input will have objects of different non zero colors. \n2) Create an output grid of 0s of the same size. \n3) Take the leftmost obj and copy and align to the left topmost part of the output grid. Then take the second leftmost obj in the input. and align it in the output to the bottom rightmost block of the previously placed object, do the same for the third obj excpet place it at the rightmost bottom of the previous 2nd obj\n4) Repeat until all objects have been place, not the anchor is at the rightmost colored block of the previously placed block, that block, the newly placed block will overlap the old block if there is any overlap color that block with the newest one.", "nlp_program": "1) Interpret the input grid as a set of objects, where each object is a maximal 4-connected group of non-zero cells of the same color.\n2) Create an output grid of the same dimensions as the input, initialized with 0s.\n3) Order the objects by increasing leftmost column index (i.e., the minimum column occupied by the object). Break ties by increasing topmost row index (i.e., the minimum row occupied by the object).\n4) Define each object’s intrinsic shape relative to its own top-left cell (the cell at its minimum row and minimum column).\n5) Place the first (leftmost) object onto the output so that its top-left cell aligns with the top-left corner of the output grid (row 0, column 0). Copy all its colored cells to the output according to its shape.\n6) For each subsequent object in the ordered list:\n   a) Identify the bottom-rightmost colored cell of the most recently placed object on the output (the cell with the greatest row index; if tied, choose the one with the greatest column index among those maximal-row cells).\n   b) Align the top-left cell of the current object’s shape to that bottom-rightmost cell position identified in step 6a.\n   c) Copy the current object’s colored cells onto the output at the aligned positions. If any copied cell overlaps an existing colored cell, overwrite the existing color with the current object’s color.\n7) Repeat step 6 until all objects have been placed.\n8) Return the resulting output grid.", "variations": ["1) Identify all colored objects in the input and sort them by the x-coordinate of their leftmost pixel (ascending).\n2) Initialize an empty output grid of 0s with the same dimensions as the input.\n3) Set an anchor at the top-left corner of the output grid.\n4) For each object in the sorted list: translate the object so that its top-leftmost colored pixel aligns with the current anchor, then paste it onto the output, overwriting any existing colors where overlap occurs.\n5) Update the anchor to the absolute position of the rightmost colored pixel of the object just placed. Repeat until all objects are placed.", "1) Partition the input into distinct colored objects and order them from leftmost to rightmost using their minimum x-coordinate.\n2) Create a zero-filled output grid matching the input size.\n3) For the first object, position it so its top-leftmost colored cell sits at the top-left corner of the output and draw it, overwriting as needed.\n4) For each subsequent object: find the rightmost colored cell of the previously placed composite, and place the next object so that its top-leftmost colored cell coincides with that rightmost cell; draw it with newest-color priority on overlaps.\n5) Continue until all objects have been positioned in sequence.", "1) Extract connected colored components and sort them by their left boundary from smallest to largest.\n2) Initialize an output canvas of zeros with identical dimensions to the input.\n3) Maintain a moving anchor that starts at the output’s top-left cell.\n4) Iterate through the sorted components: stamp each component by aligning its earliest pixel in reading order (top-to-bottom, left-to-right within the object) to the current anchor; when stamping, any overlapping cells take the color of the most recently stamped component.\n5) After each stamp, move the anchor to the rightmost colored pixel currently present in the output (from the component just added). Continue until all components are stamped."], "llm_error": null, "all_test_hashes": ["11ee81d1"], "timestamp": 1758194433.6783335}
{"task_id": "045e512c", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 8, 8, 0, 2, 2, 2, 0, 2, 2, 2, 0, 2, 2, 2], [0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2], [0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output_hash": "d2df14d7", "output_sha1": "bdffc2fca6ecddaf8575a19e37f94e4ecafa2426", "ok": true, "insts": ["1. Find the largest 8-connected shape and call it the big object.\n2. Treat each single cell as a small marker.\n3. For each marker, pick the closest of the 8 directions (N, NE, E, SE, S, SW, W, NW) from the big object’s center toward the marker.\n4. Slide a copy of the big object step by step in that direction.\n5. Stop when the copy is at least one cell away from the original big object and covers the marker’s cell.\n6. Recolor the copy with the marker’s color.\n7. Keep the original big object unchanged.\n8. Remove all the marker cells."], "insts_text": "1. Find the largest 8-connected shape and call it the big object.\n2. Treat each single cell as a small marker.\n3. For each marker, pick the closest of the 8 directions (N, NE, E, SE, S, SW, W, NW) from the big object’s center toward the marker.\n4. Slide a copy of the big object step by step in that direction.\n5. Stop when the copy is at least one cell away from the original big object and covers the marker’s cell.\n6. Recolor the copy with the marker’s color.\n7. Keep the original big object unchanged.\n8. Remove all the marker cells.", "nlp_program": "1) Detect objects\n\n2) Identify the largest 8-connected component → this is the big object.\n   Use the big object’s centroid as its center.\n\n3) Identify markers\n   Treat every single-cell component as a marker.\n\n4) For each marker (any order):\n   a) Choose direction\n      Pick the one of {N, NE, E, SE, S, SW, W, NW} whose heading best aligns with the vector from the big object’s center to the marker.\n   b) Place a copy\n      Start a copy of the big object and slide it stepwise along that direction.\n      Stop at the first position where:\n      • The copy covers the marker’s cell, and\n      • The copy is at least one cell away from the original big object (no 8-adjacent contact).\n   c) Recolor the entire copy with the marker’s color.\n\n5) Keep the original big object unchanged.\n\n6) Remove all marker cells.", "variations": ["1. Identify the largest 8-connected component as the anchor object.\n2. Treat every single-cell element as a beacon.\n3. For each beacon, choose the nearest compass direction (N, NE, E, SE, S, SW, W, NW) from the anchor’s center toward the beacon.\n4. Create a one-cell-wide exclusion moat around the anchor (for spacing only).\n5. Move a duplicate of the anchor one step at a time along the chosen direction, skipping any position that overlaps the anchor or its moat.\n6. Stop at the first position where the duplicate covers the beacon’s cell.\n7. Recolor the duplicate with the beacon’s color.\n8. Leave the anchor unchanged and delete all beacon cells.", "1. Detect the largest 8-connected region and mark it as the template.\n2. Treat each isolated single cell as a cue.\n3. For each cue, snap the vector from the template’s center to the cue to the closest of the 8 compass directions.\n4. From the cue, trace backward along that direction toward the template and find the nearest placement on this line where a copy of the template would not touch the original (at least one cell gap).\n5. Place the copy at that location so that it covers the cue’s cell.\n6. Recolor the placed copy with the cue’s color.\n7. Keep the original template unchanged.\n8. Remove all cue cells.", "1. Select the largest 8-connected cluster and label it the source object.\n2. Consider every single-cell entity as a tag.\n3. For each tag, quantize the direction from the source’s center to the tag to one of N, NE, E, SE, S, SW, W, NW.\n4. Along that direction, compute the minimal translation of the source such that the translated copy includes the tag cell and remains at least one cell away from the original everywhere.\n5. Create a copy of the source at that translated position.\n6. Color the copy with the tag’s color.\n7. Keep the original source object intact.\n8. Delete all tag cells."], "llm_error": null, "all_test_hashes": ["d2df14d7"], "timestamp": 1758196321.3352697}
{"task_id": "0520fde7", "split": "training", "test_index": 0, "output": [[2, 0, 2], [0, 0, 0], [0, 0, 0]], "output_hash": "e1a4b954", "output_sha1": "55e0f8af7ee14f5956eb99d4e7da7ca2e0f1a460", "ok": true, "insts": ["1) Split the grid at the vertical divider into left and right halves\n2) From the divider, take equal-width slices inward from both halves to form the output band\n3) For each position in this band, set the cell to 2 only if both corresponding cells in the left and right slices are color 1; otherwise set it to 0\n4) Leave all other regions unchanged; the band is the output"], "insts_text": "1) Split the grid at the vertical divider into left and right halves\n2) From the divider, take equal-width slices inward from both halves to form the output band\n3) For each position in this band, set the cell to 2 only if both corresponding cells in the left and right slices are color 1; otherwise set it to 0\n4) Leave all other regions unchanged; the band is the output", "nlp_program": "1) Use the given vertical divider column D.\n2) Use a given count m. Select columns D-1 through D-m (left of D) and columns D+1 through D+m (right of D) as the source slices.\n3) Create a new output grid with the same number of rows as the input and with m columns (columns 1 to m).\n4) For each row r and for each j from 1 to m: if input cells (row r, column D-j) and (row r, column D+j) both equal 1, set output cell (row r, column j) to 2; otherwise set it to 0.\n5) Output only this band grid; do not copy any other regions.", "variations": ["1) Mark a central band hugging the vertical divider, with width matching the inward slices from each half\n2) Reflect the left half across the divider onto the band and, independently, reflect the right half across the divider onto the same band\n3) For each band position, set it to 2 if both reflected values are color 1; otherwise set it to 0\n4) Leave all other cells as they are; the band is the output", "1) For each offset k from the vertical divider, pair the cell k steps left of the divider with the cell k steps right of the divider\n2) Create the output band along the divider by assigning one band position per offset k\n3) Write 2 at a band position only if both paired cells are color 1; otherwise write 0\n4) Do not modify any other area; only the band constitutes the output", "1) From both halves, take equal-width inward strips adjacent to the divider to define the target band\n2) Make a mask of color-1 cells for the left strip and another mask for the right strip\n3) On the band, write color 2 where both masks are true at corresponding offsets; write 0 where either mask is false\n4) Keep everything outside the band unchanged; the band is the output"], "llm_error": null, "all_test_hashes": ["e1a4b954"], "timestamp": 1758198966.746115}
{"task_id": "05269061", "split": "training", "test_index": 0, "output": [[2, 1, 4, 2, 1, 4, 2], [1, 4, 2, 1, 4, 2, 1], [4, 2, 1, 4, 2, 1, 4], [2, 1, 4, 2, 1, 4, 2], [1, 4, 2, 1, 4, 2, 1], [4, 2, 1, 4, 2, 1, 4], [2, 1, 4, 2, 1, 4, 2]], "output_hash": "28791b62", "output_sha1": "fae350de028f19dbfef107ee06c63a50c221b5c9", "ok": true, "insts": ["1) Keep the output the same size as the input.\n2) Identify the 7  left to rigt(direction is from left to right(the largest diagonal is from the leftmost bottom to the rightmost top) )diagonals and collect the 3 non-zero colors present in the input.\n3) Choose an ordering of these 3 colors by taking the first non-zero diagonal encountered and using it to define a repeating cycle of length 3.\n4) Traverse the diagonals in order and fill any zero diagonal with the next color in the cycle that differs from its immediate neighboring diagonals; preserve all pre-colored diagonals.\n5) Produce the completed grid using only the original 3 colors, such that no diagonal has neighbor diagonals with the same color."], "insts_text": "1) Keep the output the same size as the input.\n2) Identify the 7  left to rigt(direction is from left to right(the largest diagonal is from the leftmost bottom to the rightmost top) )diagonals and collect the 3 non-zero colors present in the input.\n3) Choose an ordering of these 3 colors by taking the first non-zero diagonal encountered and using it to define a repeating cycle of length 3.\n4) Traverse the diagonals in order and fill any zero diagonal with the next color in the cycle that differs from its immediate neighboring diagonals; preserve all pre-colored diagonals.\n5) Produce the completed grid using only the original 3 colors, such that no diagonal has neighbor diagonals with the same color.", "nlp_program": "1) Keep the output grid the same size as the input grid.\n2) Use a 4x4 grid with rows 1-4 (top to bottom) and columns 1-4 (left to right).\n3) Define the 7 diagonals running from bottom-left to top-right:\n   - Diagonal 1: (row 4, col 1)\n   - Diagonal 2: (row 3, col 1) and (row 4, col 2)\n   - Diagonal 3: (row 2, col 1), (row 3, col 2), (row 4, col 3)\n   - Diagonal 4: (row 1, col 1), (row 2, col 2), (row 3, col 3), (row 4, col 4)\n   - Diagonal 5: (row 1, col 2), (row 2, col 3), (row 3, col 4)\n   - Diagonal 6: (row 1, col 3), (row 2, col 4)\n   - Diagonal 7: (row 1, col 4)\n4) Read the three non-zero colors present anywhere in the input grid; call them the “three colors.”\n5) Starting from Diagonal 1 and moving to Diagonal 7, locate the first diagonal that has at least one non-zero cell; call this the “seed diagonal.”\n6) On the seed diagonal, read cells in order from bottom-left to top-right and record the first three non-zero colors exactly as they appear; this ordered list is the color cycle [C1, C2, C3].\n7) For each diagonal from Diagonal 1 to Diagonal 7:\n   - If the diagonal has any non-zero cell, copy all its cells to the same positions in the output and do not change them.\n   - If every cell in the diagonal is zero, assign a single color to the entire diagonal as follows:\n     a) If a previous diagonal (immediately before in step order) exists and is already colored with one of C1, C2, or C3, choose the first color in [C1, C2, C3] that is not equal to that previous diagonal’s color.\n     b) If a next diagonal (immediately after in step order) already has a non-zero color in the input, and it matches the color chosen in step 7a, then choose the next color in [C1, C2, C3] that differs from both neighbors.\n     c) Set all cells in the current diagonal to the chosen color.\n8) After processing all diagonals, ensure only the three colors are used by leaving all pre-colored cells unchanged and filling only zeros as specified.\n9) Output the completed 4x4 grid where no two neighboring diagonals (in the order defined in step 3) have the same color.", "variations": ["1) Keep the output the same size as the input.\n2) Identify the 7 left-to-right diagonals and determine the set of the 3 non-zero colors present in the input.\n3) Read the largest diagonal (from leftmost bottom to rightmost top) and record the order in which its non-zero colors first appear; extend this order with any remaining colors from the set to form a repeating 3-color cycle.\n4) Starting from the central (largest) diagonal, expand outward alternately to the left and right: for each diagonal that is zero, assign the next color in the cycle that differs from both immediate neighboring diagonals; keep pre-colored diagonals unchanged.\n5) Output the completed grid using only the original 3 colors, ensuring no two neighboring diagonals share the same color.", "1) Keep the output the same size as the input.\n2) Extract the 7 left-to-right diagonals and collect exactly the 3 non-zero colors used in the input.\n3) Scan the diagonals from leftmost to rightmost; record the first time each of the 3 colors appears to define an ordered list, and use this list as the repeating 3-color cycle.\n4) Traverse the diagonals from left to right; for any zero diagonal, choose the next color in the cycle that is different from both its immediate neighbors (use the known color on the right if already pre-colored, otherwise only the left neighbor), and leave all pre-colored diagonals intact.\n5) Produce the final grid with only the original 3 colors, guaranteeing that adjacent diagonals do not share the same color.", "1) Keep the output the same size as the input.\n2) Determine the 7 left-to-right diagonals and the set of the 3 non-zero colors present in the input.\n3) Fix a cyclic order of the 3 colors by taking the first non-zero diagonal encountered and mapping its color to position 0 of a 3-step cycle; assign the remaining two colors to positions 1 and 2 in the order of their first appearance.\n4) Assign colors to diagonals by index modulo 3 using this cycle, preserving all pre-colored diagonals; if any conflict with a pre-colored neighbor arises, rotate the global cycle and reapply until all neighboring diagonals differ.\n5) Output the filled grid using only the original 3 colors, with no two neighboring diagonals having the same color."], "llm_error": null, "all_test_hashes": ["28791b62"], "timestamp": 1758200139.7479694}
{"task_id": "05a7bcf2", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 4, 3, 3, 0, 0, 0], [2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 4, 3, 3, 0, 0, 0], [2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 4, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 3, 3, 0, 0, 0, 0], [2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 3, 3, 0, 0, 0, 0], [2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 3, 3, 0, 0, 0, 0], [2, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 3, 3, 0, 0, 0, 0], [2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 3, 0, 0, 0, 0, 0], [2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 3, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 3, 0, 0, 0, 0, 0], [2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 3, 0, 0, 0, 0, 0], [2, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3], [2, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 4, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output_hash": "5428947d", "output_sha1": "9a83eb74df5f414ecd848c90b649301b2e17c1e9", "ok": false, "insts": ["1) There are three groups of objects, 1st group all colored with color 4, the second group consists of 1 verticle bar colored 8, the second group one continogous object that vertically goes down but is irregular.(color 2). The second onbject seperates the 1st group from the second group. \n2)For the first group find the direction that face the second verticle bar \n3) In that direction create a projection that start from the base in that direction and extends like a coloumn in the direction of the second vertical bar, when the coloumn hits the second vertical bar the coloumn changed color from 4 to 8(before it was 4). Then goes straight to the third group. the coloumn pushes the intersection of the third group witht he coloumn in the direction that it is extending, leaving everything else intact, until the intersection touches a wall. When it does touch a wall this stops. \n4) Color the orgiinal group 1 with 3(only the group not the col that extends from the base). \n5) We essentially have the coloumn extending horizontally in the direction of the 2nd group, when it instersects wioth the 2nd group it changes colors, when it intersection wiht the third group it pushes the intersection are in that direction(the intersection only keeps the color, but the trail is still 8(the color of the 2nd object), sort of like a tetris, the intersection goes down(horizontally), and the col fill up the rest of the space."], "insts_text": "1) There are three groups of objects, 1st group all colored with color 4, the second group consists of 1 verticle bar colored 8, the second group one continogous object that vertically goes down but is irregular.(color 2). The second onbject seperates the 1st group from the second group. \n2)For the first group find the direction that face the second verticle bar \n3) In that direction create a projection that start from the base in that direction and extends like a coloumn in the direction of the second vertical bar, when the coloumn hits the second vertical bar the coloumn changed color from 4 to 8(before it was 4). Then goes straight to the third group. the coloumn pushes the intersection of the third group witht he coloumn in the direction that it is extending, leaving everything else intact, until the intersection touches a wall. When it does touch a wall this stops. \n4) Color the orgiinal group 1 with 3(only the group not the col that extends from the base). \n5) We essentially have the coloumn extending horizontally in the direction of the 2nd group, when it instersects wioth the 2nd group it changes colors, when it intersection wiht the third group it pushes the intersection are in that direction(the intersection only keeps the color, but the trail is still 8(the color of the 2nd object), sort of like a tetris, the intersection goes down(horizontally), and the col fill up the rest of the space.", "nlp_program": "1) Use a grid with rows numbered from top to bottom starting at 1, and columns from left to right starting at 1.\n2) Identify groups by color: group 1 = all cells with value 4, group 2 = the vertical bar made of value 8 in a single column, group 3 = all cells with value 2.\n3) Let the column of group 2 (the 8-bar) be the bar column. If every column index of group 1 is less than the bar column, set the direction to right. If every column index of group 1 is greater than the bar column, set the direction to left.\n4) Select the bottommost row that contains at least one cell with value 4 from group 1. Call this the beam row.\n5) In the beam row, choose the edge cell of group 1 that faces the bar: if direction is right, pick the rightmost 4 in this row; if left, pick the leftmost 4 in this row. Start the beam from the next cell in the chosen direction.\n6) From the start cell, move step by step in the chosen direction along the beam row. For each empty cell (no value assigned), set it to 4, stopping immediately before the bar column.\n7) In the bar column on the beam row, set that cell to 8. Continue in the same row and direction: for each empty cell after the bar, set it to 8, until you reach a cell with value 2.\n8) When you reach the first cell with value 2 in the beam row, take the maximal contiguous block of 2s in that row starting at this cell. Shift this entire block one cell at a time in the beam direction until the front of the block touches the grid edge (wall). After each single-cell shift, set the newly vacated cell (nearest to the bar) to 8. Stop when the front cell is at the wall.\n9) Do not change any other cells.\n10) Finally, change all original cells of group 1 (all cells that were 4 before step 5) to value 3. Do not change the beam cells added in steps 6–8.", "variations": ["1) Identify three groups: Group A is a cluster colored 4; Group B is a single vertical bar colored 8; Group C is one contiguous, vertically stretching irregular object colored 2, located beyond Group B. Determine the side of Group A that directly faces Group B.\n2) From the facing edge of Group A, cast a straight horizontal ray toward Group B, laying down a continuous column starting at the base edge of Group A.\n3) Grow the column with color 4 until it first contacts Group B; from that contact point onward, recolor the entire advancing column to color 8 as it continues in the same direction toward Group C.\n4) When the 8-colored column intersects Group C, take exactly the overlapping cells of Group C and push them further along the column’s direction until they hit a wall, preserving their original color while leaving 8 behind where they vacate.\n5) Recolor only the original body of Group A (not the extended column) to color 3.\n\n1) Define three sets: Set 1 is a block of cells colored 4; Set 2 is a lone vertical bar colored 8 that lies between Set 1 and Set 3; Set 3 is a single connected object that descends irregularly and is colored 2.\n2) Find the boundary of Set 1 that faces Set 2 and choose the lowest base cell on that boundary as the launch point.\n3) Build a straight horizontal bridge outward from that base toward Set 2; all new bridge cells start as color 4 until any cell touches Set 2, at which moment all subsequently added bridge cells (including the touch cell) are color 8.\n4) Continue extending the 8-colored bridge into Set 3; wherever the bridge overlaps Set 3, cut out that overlapped silhouette and slide it forward along the bridge’s direction until it contacts a wall, leaving an 8 trail behind while the moved silhouette keeps its original color.\n5) Paint the original Set 1 region to color 3, leaving the bridge as-is.\n\n1) Partition the scene into: Group One (color 4 cluster), Group Two (a vertical bar, color 8, separating One from Three), and Group Three (one vertically elongated, irregular, contiguous object, color 2).\n2) Determine the horizontal direction from Group One that points directly toward Group Two, and create a conveyor line starting at Group One’s base edge along that direction.\n3) Advance the conveyor line cell by cell: it is color 4 until it reaches any cell of Group Two, after which the conveyor line switches to color 8 for all further advancement.\n4) Upon contacting Group Three, collect exactly the intersection footprint between the conveyor and Group Three and translate that footprint forward along the conveyor until a boundary is hit, preserving the footprint’s original color while the conveyor path behind remains color 8.\n5) Recolor the entirety of Group One’s original area to color 3, excluding the conveyor extension."], "llm_error": null, "all_test_hashes": ["fbae1fff"], "timestamp": 1758228095.285695}
{"task_id": "05f2a901", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0], [0, 8, 8, 2, 2, 0, 0, 0, 0, 0], [0, 8, 8, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output_hash": "ac0bac10", "output_sha1": "e3a696914ecacf8e60d046a70dec00eb88fce80c", "ok": true, "insts": ["1) Output grid same size as input, Copy the  square shape(the color 8 obj) into he output grid same place. \n2) The second obj color 2, should move either vertically or horizontall, based on how the 1st object is facing it, if the first object is horizontally placed relative to it, that is the horizontal dis is greater than the vertical then move the 2nd object horizontally until you toch the 1st obj, if it is vertical then move the 2n obj vertically, the input grid will always be such that if you move the 2nd obj vertically or horizontally woul will touch the 1st obj. \n3) Return this"], "insts_text": "1) Output grid same size as input, Copy the  square shape(the color 8 obj) into he output grid same place. \n2) The second obj color 2, should move either vertically or horizontall, based on how the 1st object is facing it, if the first object is horizontally placed relative to it, that is the horizontal dis is greater than the vertical then move the 2nd object horizontally until you toch the 1st obj, if it is vertical then move the 2n obj vertically, the input grid will always be such that if you move the 2nd obj vertically or horizontally woul will touch the 1st obj. \n3) Return this", "nlp_program": "1) Make an empty output grid with the same size as the input.\n2) Copy every cell with value 8 from the input to the same row and column in the output. Leave all other output cells empty.\n3) In the input, collect all cells with value 2 as one object.\n4) Let TL2 be the top-left cell of the value-2 object (smallest row; if tied, smallest column). Let TL8 be the top-left cell of the value-8 object.\n5) Let row2 = row of TL2, col2 = column of TL2. Let row8 = row of TL8, col8 = column of TL8.\n6) If |col2 − col8| > |row2 − row8|, set the move direction to horizontal; otherwise set it to vertical.\n7) If horizontal:\n   - If col2 < col8, set direction = right. If col2 > col8, set direction = left.\n   If vertical:\n   - If row2 < row8, set direction = down. If row2 > row8, set direction = up.\n8) Repeat until the value-2 object is immediately adjacent to any value-8 cell along the move direction:\n   - Shift every cell of the value-2 object by one cell in the chosen direction (up, down, left, or right).\n9) After stopping, write the value-2 object into the output at its final rows and columns.\n10) Return the output grid.", "variations": ["1) Make the output grid the same dimensions as the input, and place the color-8 square exactly where it appears in the input.\n2) Measure the horizontal and vertical offsets between the color-2 object and the color-8 square; if the horizontal offset is larger in magnitude, slide the color-2 object horizontally toward the color-8 until it touches; otherwise slide it vertically until it touches. The path is guaranteed to reach the color-8.\n3) Return the result.\n", "1) Initialize an empty output grid matching the input size; copy only the color-8 square to the identical coordinates.\n2) Apply a one-axis “gravity” to the color-2 object directed toward the color-8: choose horizontal gravity if the column gap is greater than the row gap; otherwise choose vertical gravity. Let the color-2 object fall along that axis until it collides with the color-8 square.\n3) Return the output.\n", "1) Create an output grid with the same size as the input and fix the color-8 square in its original position.\n2) Project the color-2 object onto the axis of greatest separation from the color-8 (columns if |dx| > |dy|, rows otherwise). Translate the color-2 object strictly along that single axis until it is in contact with the color-8 square, without rotating or reshaping it.\n3) Return this."], "llm_error": null, "all_test_hashes": ["ac0bac10"], "timestamp": 1758228894.9375138}
{"task_id": "0607ce86", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 8, 2, 2, 0, 2, 2, 8, 2, 2, 0, 2, 2, 8, 2, 2, 0, 0, 0, 0], [0, 3, 3, 8, 3, 3, 0, 3, 3, 8, 3, 3, 0, 3, 3, 8, 3, 3, 0, 0, 0, 0], [0, 3, 3, 8, 3, 3, 0, 3, 3, 8, 3, 3, 0, 3, 3, 8, 3, 3, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 8, 2, 2, 0, 2, 2, 8, 2, 2, 0, 2, 2, 8, 2, 2, 0, 0, 0, 0], [0, 3, 3, 8, 3, 3, 0, 3, 3, 8, 3, 3, 0, 3, 3, 8, 3, 3, 0, 0, 0, 0], [0, 3, 3, 8, 3, 3, 0, 3, 3, 8, 3, 3, 0, 3, 3, 8, 3, 3, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 8, 2, 2, 0, 2, 2, 8, 2, 2, 0, 2, 2, 8, 2, 2, 0, 0, 0, 0], [0, 3, 3, 8, 3, 3, 0, 3, 3, 8, 3, 3, 0, 3, 3, 8, 3, 3, 0, 0, 0, 0], [0, 3, 3, 8, 3, 3, 0, 3, 3, 8, 3, 3, 0, 3, 3, 8, 3, 3, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output_hash": "b51684b4", "output_sha1": "0f7273a4c86faf56fe833769548df882d94d8fa4", "ok": true, "insts": ["1) The output grid will be the same size as the input\n2) In the input there are 9 obj, int he objects as well as outside there are random blocks spread across, take out these random patterns. \n3) The 9 obj are indentical, but some have random pieces, to find the correct prototype,(they are 3 * 3) find the majority block color for each obj across the 9, then color all of them as so. \n4) Return the output grid without the random noise, and identical objects."], "insts_text": "1) The output grid will be the same size as the input\n2) In the input there are 9 obj, int he objects as well as outside there are random blocks spread across, take out these random patterns. \n3) The 9 obj are indentical, but some have random pieces, to find the correct prototype,(they are 3 * 3) find the majority block color for each obj across the 9, then color all of them as so. \n4) Return the output grid without the random noise, and identical objects.", "nlp_program": "1) Create an output grid with the same size as the input. Copy all input cells to the output.\n2) Partition the grid into non-overlapping 3x3 blocks: rows 1-3, 4-6, 7-9, ... and columns 1-3, 4-6, 7-9, ... (stop when you reach the grid edges).\n3) For each of the 9 relative positions inside a 3x3 block (r=1..3, c=1..3):\n   - Count, across all 3x3 blocks, how many times each color appears at that same relative position (r,c).\n   - Select the color with the highest count for that relative position.\n4) For every 3x3 block and for each relative position (r,c) inside it, set that cell to the selected majority color from step 3 for that relative position.\n5) Set every cell that is not inside any 3x3 block from step 2 to value 0.\n6) Output the resulting grid.", "variations": ["1) Keep the output grid the same size as the input\n2) Detect the 9 intended 3×3 objects and ignore isolated blocks that do not form a full 3×3\n3) Among the 9 objects, select the one with the smallest total difference to the others as the prototype\n4) Replace all 9 objects with this prototype and clear any pixels outside these placements as background", "1) Maintain the output grid size equal to the input\n2) Align the 9 target 3×3 objects and build a consensus mask: a cell is in the object if at least 5 of the 9 have a non-background value there\n3) For each masked cell, choose the most frequent color among the 9 and set unmasked cells to background, forming a template\n4) Stamp this template onto all 9 positions and remove all other pixels as noise", "1) Keep the output grid identical in dimensions to the input\n2) Identify the dominant background color of the grid\n3) For each offset position within the 3×3 objects, select the most common non-background color across the 9 objects to construct a prototype\n4) Fill each of the 9 objects with this prototype and set every other pixel, inside and outside, to the background color"], "llm_error": null, "all_test_hashes": ["b51684b4"], "timestamp": 1758229443.0872633}
{"task_id": "0692e18c", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 3, 0, 3, 0], [3, 3, 0, 3, 3, 0, 0, 0, 0], [0, 0, 3, 0, 0, 3, 0, 0, 0], [3, 0, 3, 3, 0, 3, 0, 0, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 3, 0, 0, 0]], "output_hash": "219e31ec", "output_sha1": "b9d56dea7f9099fe631299bd3aedbe96338d8132", "ok": false, "insts": ["1) The output should be 9 * 9, the input 3 * 3. \n2) find the edge direction of the input obj, by looking at the edges of the shape in the input(the shape is non 0 color), the directions might be up, down, right, left, diagonally, or some subset containing more than one. For example a cross wil result in an up down, right and left direction. \n3)The take the input grid and invert the colors, the 0s now have the color of the obj and the obj has zero and repeat this object in the direction previously calculated. \n4) The final grid 9 * 9 will be the output. \n5) The edge blocks are defined as block with only 1 neighbor"], "insts_text": "1) The output should be 9 * 9, the input 3 * 3. \n2) find the edge direction of the input obj, by looking at the edges of the shape in the input(the shape is non 0 color), the directions might be up, down, right, left, diagonally, or some subset containing more than one. For example a cross wil result in an up down, right and left direction. \n3)The take the input grid and invert the colors, the 0s now have the color of the obj and the obj has zero and repeat this object in the direction previously calculated. \n4) The final grid 9 * 9 will be the output. \n5) The edge blocks are defined as block with only 1 neighbor", "nlp_program": "1) Create an empty 9x9 output grid filled with 0.\n2) From the 3x3 input, record the single non-zero value as color C.\n3) Mark edge cells in the input: For each cell in rows 1-3, columns 1-3 with value != 0, count its neighbors in the 8 surrounding positions (stay inside the 3x3). If exactly 1 neighbor has value != 0, mark this cell as an edge cell.\n4) Collect directions from the input: For each marked edge cell, find its single non-zero neighbor. Record the direction from the neighbor to the edge cell as one of: up, down, left, right, up-left, up-right, down-left, down-right.\n5) Build the inverted 3x3 object: For each cell of the input 3x3, if value == 0 set it to C; if value == C set it to 0. Keep this as the inverted object.\n6) Place the inverted object into the 9x9 output according to the recorded directions:\n   - up: rows 1-3, columns 4-6\n   - down: rows 7-9, columns 4-6\n   - left: rows 4-6, columns 1-3\n   - right: rows 4-6, columns 7-9\n   - up-left: rows 1-3, columns 1-3\n   - up-right: rows 1-3, columns 7-9\n   - down-left: rows 7-9, columns 1-3\n   - down-right: rows 7-9, columns 7-9\n   For each recorded direction, copy the inverted 3x3 values into the corresponding 3x3 block in the output at the same relative positions.\n7) Leave all other output cells as 0. The output is the 9x9 grid.", "variations": ["1) The output should be 9 by 9, the input is 3 by 3.\n2) Determine directions by which sides/corners of the object’s bounding box are touched by nonzero cells: touching top gives up, bottom gives down, left gives left, right gives right; touching a corner implies the corresponding diagonal.\n3) Invert the input colors so that zeros take the object’s color and object cells become zero.\n4) Place the inverted 3 by 3 block at the center of a 9 by 9 canvas and replicate it every 3 cells along each direction found, stopping at the edges.\n5) The final 9 by 9 grid is the output.\n", "1) The output should be 9 x 9, the input is 3 x 3.\n2) Trace the perimeter of the nonzero shape; collect the unique compass moves observed along the trace as the direction set (up, down, left, right, and diagonals as applicable).\n3) Produce the inverted version of the input by swapping foreground and background colors.\n4) Starting from the original 3 x 3 location, stamp the inverted tile along each direction in the set at multiples of 3 cells, within the 9 x 9 bounds.\n5) Output the resulting 9 x 9 grid.\n", "1) The output must be 9*9, the input is 3*3.\n2) Compute the centroid of the nonzero shape and form vectors from the centroid to all edge cells (cells with at least one zero neighbor); reduce these vectors to unit compass directions to get the direction set (including diagonals if present).\n3) Invert the colors: zeros become the object’s color and the object becomes zero.\n4) Fill a 3*3 lattice over the 9*9 area using the inverted tile; keep only those lattice placements whose direction from the center lies in the direction set.\n5) The completed 9*9 grid is the output.\n"], "llm_error": null, "all_test_hashes": ["1f3df9ac"], "timestamp": 1758230227.783954}
{"task_id": "06df4c85", "split": "training", "test_index": 0, "output": [[0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 8, 8, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 8, 8, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 8, 8, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 8, 8, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 8, 8, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 3, 3, 4, 0, 0], [0, 0, 4, 0, 0, 4, 8, 8, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 3, 3, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 8, 8, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 8, 8, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0]], "output_hash": "fd226d18", "output_sha1": "c9836fd92ba95261f7671c1405595126fc4f5070", "ok": true, "insts": ["1) Copy the input grid into the output grid\n2) You will a mesh of vertical and harizontal bars, with the opening (the squares), sometimes colored. The goal is to connect teh squares vertically or horizontally. \n3) If there is another square of similar color int he verticle or horizontal direction, color all squares in between. Do this for all squares and output."], "insts_text": "1) Copy the input grid into the output grid\n2) You will a mesh of vertical and harizontal bars, with the opening (the squares), sometimes colored. The goal is to connect teh squares vertically or horizontally. \n3) If there is another square of similar color int he verticle or horizontal direction, color all squares in between. Do this for all squares and output.", "nlp_program": "1) Copy the entire input grid to the output grid.\n2) For each row from top to bottom: for every pair of columns (c1, c2) with c1 < c2, if the cells at (row, c1) and (row, c2) have the same color and all cells in columns c1+1 to c2-1 in that row are blank, set each cell in columns c1+1 to c2-1 of that row to that color.\n3) For each column from left to right: for every pair of rows (r1, r2) with r1 < r2, if the cells at (r1, column) and (r2, column) have the same color and all cells in rows r1+1 to r2-1 in that column are blank, set each cell in rows r1+1 to r2-1 of that column to that color.\n4) Leave all other cells unchanged.", "variations": ["1) Duplicate the input grid into the output grid\n2) For each row, scan left to right; whenever two squares of the same color appear with only empty openings between them, fill all intervening openings with that color\n3) Repeat the same process for each column, top to bottom, then output", "1) Start with the output grid identical to the input\n2) For every colored square, extend searches horizontally and vertically through openings until a bar or grid edge is reached; if an identical color is encountered with only uncolored openings in between, color those intervening openings\n3) Keep iterating over all colored squares until no new openings are colored, then output", "1) Initialize the output as a copy of the input grid\n2) For each distinct color, examine every row and every column; wherever a straight segment begins and ends with that color and contains only uncolored openings between bars, color the entire interior of that segment with the same color\n3) Apply this to all colors across all lines and produce the result"], "llm_error": null, "all_test_hashes": ["fd226d18"], "timestamp": 1758230715.6107814}
{"task_id": "070dd51e", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 3, 2, 2, 2, 2, 2, 5, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 7, 7, 5, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output_hash": "17e9f808", "output_sha1": "91461335ccc42dbc5b9333bbcb9f1155c35e8ad5", "ok": true, "insts": ["1) Copy the output from the input grid\n2) There will be two pairs of similar color block that are either vertically apart or horizontally apart. Connect them using their colors. If two connections overlap, then the vertical one will be above the horizontal one."], "insts_text": "1) Copy the output from the input grid\n2) There will be two pairs of similar color block that are either vertically apart or horizontally apart. Connect them using their colors. If two connections overlap, then the vertical one will be above the horizontal one.", "nlp_program": "1) Copy the entire input grid to the output grid (same size and values).\n2) For each color that appears in exactly two cells in the input:\n   2a) If the two cells are in the same column: in the output, set every cell in that column from the upper cell’s row to the lower cell’s row (inclusive) to that color.\n   2b) If the two cells are in the same row: in the output, set every cell in that row from the left cell’s column to the right cell’s column (inclusive) to that color.\n3) Apply step 2a (all vertical fills) before step 2b (all horizontal fills). When doing step 2b, skip any cell that was changed by step 2a to a different color; leave those cells as they are.", "variations": ["1) Replicate the input grid exactly into the output\n2) For each color appearing exactly twice, draw a straight line of that color between the two matching blocks along their shared row or column; if a vertical and a horizontal line intersect, keep the vertical color on top", "1) Initialize the output as an exact copy of the provided grid\n2) For each pair of same-colored blocks aligned either in the same row or column, fill all intervening cells between them with that color; where a vertical fill crosses a horizontal fill, the vertical color takes precedence", "1) Duplicate the given grid into the result without modification\n2) Locate the two pairs of identical colors; for each pair, connect the blocks by painting a continuous segment along the single axis separating them; at any crossing, assign the cell the color of the vertical segment over the horizontal"], "llm_error": null, "all_test_hashes": ["17e9f808"], "timestamp": 1758231155.0319767}
{"task_id": "08ed6ac7", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 2, 0, 0, 0], [0, 1, 0, 0, 0, 2, 0, 0, 0], [0, 1, 0, 0, 0, 2, 0, 3, 0], [0, 1, 0, 0, 0, 2, 0, 3, 0], [0, 1, 0, 4, 0, 2, 0, 3, 0], [0, 1, 0, 4, 0, 2, 0, 3, 0], [0, 1, 0, 4, 0, 2, 0, 3, 0]], "output_hash": "db59ce61", "output_sha1": "a51926fc2948f219979e2ae4b8241012604b2679", "ok": true, "insts": ["1) Identify the height of each of the 4 vertical bars\n    2) For each bar, count how many bars are strictly taller than it; let rank = 1 + that count\n    3) Assign each bar a color equal to its rank (tallest 1, then 2, 3, 4)\n    4) Output the same input grid with these color additions\n5) Do not change the physical order, just the color based on the heights of the vertical bars spread in the input grid(they are not adjacent)"], "insts_text": "1) Identify the height of each of the 4 vertical bars\n    2) For each bar, count how many bars are strictly taller than it; let rank = 1 + that count\n    3) Assign each bar a color equal to its rank (tallest 1, then 2, 3, 4)\n    4) Output the same input grid with these color additions\n5) Do not change the physical order, just the color based on the heights of the vertical bars spread in the input grid(they are not adjacent)", "nlp_program": "1) For each of the 4 vertical bars, count its height as the number of cells that belong to that bar.\n2) For each bar, count how many of the other 3 bars have a greater height; set the bar’s color value to 1 plus that count (tallest gets 1, next 2, then 3, shortest 4).\n3) For each bar, set every cell in that bar’s column range to the bar’s color value from step 2.\n4) Do not change any cell positions or shapes; only change colors.\n5) Output the same grid with the new colors applied to the bars.", "variations": ["1) Scan the grid to record every bar’s height along with its original position\n2) Create a list of the distinct heights and sort it in descending order\n3) For each distinct height in order, assign rank = 1 + the index in this sorted list\n4) Color every bar with that height using the corresponding rank color\n5) Output the grid with colors applied at the original positions, without changing bar order", "1) Group all bars by their exact height while preserving each bar’s position in the grid\n2) Order these groups by height from tallest to shortest\n3) Starting from the tallest group, assign ranks incrementally (tallest rank = 1)\n4) Apply the rank as the color to every bar in each group\n5) Render the original grid with bars left in place, only colors updated", "1) Initialize all bars as uncolored and note their heights at their current positions\n2) While there remain uncolored bars, find the maximum height among them\n3) Assign the next available rank (starting at 1) to all bars with that maximum height\n4) Color those bars with the rank value, leaving their positions unchanged\n5) Continue until all bars are colored, then output the grid with the applied colors"], "llm_error": null, "all_test_hashes": ["db59ce61"], "timestamp": 1758231531.9708035}
{"task_id": "09629e4f", "split": "training", "test_index": 0, "output": [[6, 4, 0, 5, 0, 3, 0, 5, 0, 4, 0], [0, 0, 3, 5, 2, 8, 6, 5, 8, 0, 2], [2, 0, 8, 5, 4, 0, 0, 5, 6, 3, 0], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [2, 0, 0, 5, 0, 3, 0, 5, 3, 6, 2], [3, 4, 6, 5, 8, 4, 2, 5, 0, 0, 4], [0, 8, 0, 5, 0, 0, 6, 5, 8, 0, 0], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 2, 4, 5, 0, 6, 4, 5, 0, 2, 8], [0, 6, 3, 5, 0, 0, 3, 5, 4, 0, 6], [0, 0, 0, 5, 2, 0, 8, 5, 3, 0, 0]], "output_hash": "e374a75f", "output_sha1": "44ac01614b6dae47f743a52cce30314b8197f350", "ok": false, "insts": ["1) Take the middle square, the square is 3 by 3. 2)As the input grid is a divided into 9 sections, take the color found in the 3 by 3 middle square, and color all respective sections fully with this color. Any other colors in the sections starts from 0 and is colored by the colors in the 3 by 3 block(including the middle 3 by 3 block). The whole thing is a grid with 9, 3 by 3 section. Leave all section that are not colored by in 3 by 3 square, as zeros"], "insts_text": "1) Take the middle square, the square is 3 by 3. 2)As the input grid is a divided into 9 sections, take the color found in the 3 by 3 middle square, and color all respective sections fully with this color. Any other colors in the sections starts from 0 and is colored by the colors in the 3 by 3 block(including the middle 3 by 3 block). The whole thing is a grid with 9, 3 by 3 section. Leave all section that are not colored by in 3 by 3 square, as zeros", "nlp_program": "1) Create a 9x9 output grid. Set all cells to 0.\n2) Read the middle 3x3 region (rows 4-6, columns 4-6). For each cell:\n   - If value equals 0, do nothing.\n   - If value is not 0, fill the matching 3x3 section with this value as follows:\n     • Cell (4,4) -> fill rows 1-3, columns 1-3\n     • Cell (4,5) -> fill rows 1-3, columns 4-6\n     • Cell (4,6) -> fill rows 1-3, columns 7-9\n     • Cell (5,4) -> fill rows 4-6, columns 1-3\n     • Cell (5,5) -> fill rows 4-6, columns 4-6\n     • Cell (5,6) -> fill rows 4-6, columns 7-9\n     • Cell (6,4) -> fill rows 7-9, columns 1-3\n     • Cell (6,5) -> fill rows 7-9, columns 4-6\n     • Cell (6,6) -> fill rows 7-9, columns 7-9", "variations": ["1) Locate the central 3 by 3 block. 2) Use its 3 by 3 cells as a template: for each cell position (row, column) in this block, assign that color to the entire 3 by 3 section at the same (row, column) among the nine sections. 3) If a template cell is 0, leave the corresponding section filled with zeros. 4) The result is a 3 by 3 array of sections, each section uniformly colored from the template.", "1) View the grid as a 3 by 3 matrix of 3 by 3 sections. 2) Read the colors from the middle section’s 3 by 3 cells. 3) For each index pair (i, j) in that middle section, flood-fill the section at position (i, j) with that color. 4) If the color read is 0, keep that section entirely zero. 5) Do this for all nine positions to complete the grid.", "1) Treat the center 3 by 3 as a key. 2) For each of its nine cells, propagate its color outward to the entire section occupying the same relative location in the overall 3 by 3 layout of sections. 3) Replace each target section with a uniform fill of that color. 4) Whenever the key cell is 0, leave the matching section as zeros."], "llm_error": null, "all_test_hashes": ["2d113f5f"], "timestamp": 1758232264.6206892}
{"task_id": "0962bcdd", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 0, 4, 0, 3, 0, 4, 0], [0, 0, 0, 0, 0, 0, 0, 4, 3, 4, 0, 0], [0, 0, 0, 0, 0, 0, 3, 3, 4, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 4, 3, 4, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 3, 0, 4, 0], [4, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 4, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 4, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 4, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output_hash": "7cb03064", "output_sha1": "8c4a1c713f47dd94b8757a741df46af7b22544af", "ok": true, "insts": ["1) There are two crosses in the input grid, the middle blocks have a different color than the other parts of the cross. \n2) Extend the middle diagnocally in each diagonal direction, by two block. \n3) Extend the cross edges(up, down, right left) by 1 block. Keep the color for the edges the same, as well as the middle the same, only extend."], "insts_text": "1) There are two crosses in the input grid, the middle blocks have a different color than the other parts of the cross. \n2) Extend the middle diagnocally in each diagonal direction, by two block. \n3) Extend the cross edges(up, down, right left) by 1 block. Keep the color for the edges the same, as well as the middle the same, only extend.", "nlp_program": "1) For each cell C that has up, down, left, and right neighbors, and the four neighbors all have the same color X, and C’s color is not X: do steps 2 and 3 for C.\n2) Diagonal extension from C: set the cells at (row-1, col-1), (row-2, col-2), (row-1, col+1), (row-2, col+2), (row+1, col-1), (row+2, col-2), (row+1, col+1), (row+2, col+2) to C’s color. If any of these positions are outside the grid, skip those positions.\n3) Edge extension from C in four directions:\n   3a) Up: let Y be the color at (row-1, col). Starting at (row-1, col), move one cell up at a time while the cell color equals Y. After the last Y-colored cell, if the next cell up is inside the grid, set that next cell to Y.\n   3b) Down: let Y be the color at (row+1, col). Starting at (row+1, col), move one cell down at a time while the cell color equals Y. After the last Y-colored cell, if the next cell down is inside the grid, set that next cell to Y.\n   3c) Left: let Y be the color at (row, col-1). Starting at (row, col-1), move one cell left at a time while the cell color equals Y. After the last Y-colored cell, if the next cell left is inside the grid, set that next cell to Y.\n   3d) Right: let Y be the color at (row, col+1). Starting at (row, col+1), move one cell right at a time while the cell color equals Y. After the last Y-colored cell, if the next cell right is inside the grid, set that next cell to Y.", "variations": ["1) Identify both crosses and note that each has a center cell with a distinct color from its arms.\n2) From each center, draw two cells out along each of the four diagonals, using the center’s color.\n3) Extend each of the four arms by adding one cell at the tip in the same direction, keeping the arm color unchanged.", "1) For each cross, separate the center tile from the four cardinal arms, preserving their respective colors.\n2) Grow the center outward by placing two cells on every diagonal ray from the center, using the center’s color.\n3) Lengthen each arm by one additional cell at its far end (up, down, left, right), matching the arm’s color.", "1) Locate the two crosses; record the center color and the arm color for each.\n2) Expand the center by propagating it two steps along all four diagonals, coloring those new diagonal cells with the center color.\n3) Extend each arm outward by exactly one cell in its direction, keeping those new cells the same color as the arms."], "llm_error": null, "all_test_hashes": ["7cb03064"], "timestamp": 1758234419.9133961}
{"task_id": "09c534e7", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0], [0, 0, 1, 1, 1, 1, 0, 0, 1, 4, 4, 4, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0], [0, 0, 1, 4, 4, 1, 1, 1, 1, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 1, 1, 4, 1, 0, 0, 1, 4, 4, 4, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0], [0, 0, 1, 1, 1, 1, 0, 0, 1, 4, 4, 4, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 8, 8, 8, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 8, 8, 8, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 8, 8, 8, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 6, 6, 1, 0], [0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 6, 6, 1, 0], [0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 6, 6, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0], [0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0]], "output_hash": "7d07c12c", "output_sha1": "ec1486dd259185251f29bf621e76c51e803e4966", "ok": false, "insts": ["1) You will see mutliple sets of rectangles connected by a line of blocks, in each set there is one none no one color block\n2) take this color and color each connected block sub rectangle(the largest rectangle such that only a border of 1s remains, the inside filled with the color)\n3)do this for each set of connected rectangles."], "insts_text": "1) You will see mutliple sets of rectangles connected by a line of blocks, in each set there is one none no one color block\n2) take this color and color each connected block sub rectangle(the largest rectangle such that only a border of 1s remains, the inside filled with the color)\n3)do this for each set of connected rectangles.", "nlp_program": "1) For each set of rectangles connected together: scan its cells row by row, left to right, until you find the only cell whose value is not 1. Record its color as the target color.\n2) For that same set: consider every possible rectangle by choosing a top-left cell and a bottom-right cell within the set (top-left row ≤ bottom-right row, top-left column ≤ bottom-right column).\n3) For each chosen rectangle: check the border cells (top row, bottom row, left column, right column). If every border cell has value 1, go to step 4 for this rectangle; otherwise skip it.\n4) For that rectangle: set every interior cell (rows between the top and bottom, columns between the left and right) to the target color. Do not change any border cells.\n5) Repeat steps 2–4 for all rectangles in the set.\n6) Repeat steps 1–5 for each remaining set of connected rectangles.", "variations": ["1) Identify groups of rectangles that are linked by a single-width path of 1s; within each group, locate the lone block that is a different color than 1\n2) Use that color as the fill color for the group\n3) For every hollow rectangle in the group (a rectangle whose border is 1s), fill its interior entirely with the chosen color, leaving the 1-border intact\n4) Repeat for all groups", "1) Partition the grid into components formed by rectangles connected via lines of 1s; in each component, find the unique non-1 colored cell\n2) Treat that cell’s color as the component’s label color\n3) For each maximal area enclosed by a 1-border inside that component, flood-fill the interior with the label color without altering the border\n4) Apply this to every component", "1) For every cluster of bordered rectangles joined by a 1-path, detect the single cell whose color differs from 1 and record that color\n2) Trace the perimeters (1-borders) of all rectangles in the cluster and identify their enclosed interiors\n3) Paint each identified interior fully with the recorded color while preserving the 1-borders\n4) Process each cluster in this manner until all interiors are filled"], "llm_error": null, "all_test_hashes": ["34e0e1dc"], "timestamp": 1758234698.919115}
{"task_id": "0a1d4ef5", "split": "training", "test_index": 0, "output": [[2, 3, 3], [4, 7, 1], [1, 3, 7], [4, 6, 2]], "output_hash": "7ea58387", "output_sha1": "3223d182633c07c0800e837526741c146d25a9a1", "ok": true, "insts": ["1) There is random noise int he output, you will see rectangles arranged in some order verticallyu and horizontally, by the number col and rows of rectangles create the grid. Say 3 rows of rectangles and 4 col, then a 3 by 4 output grid \n2)  each blocks color in the output grid corresponds to the color of the rectangle in that positions"], "insts_text": "1) There is random noise int he output, you will see rectangles arranged in some order verticallyu and horizontally, by the number col and rows of rectangles create the grid. Say 3 rows of rectangles and 4 col, then a 3 by 4 output grid \n2)  each blocks color in the output grid corresponds to the color of the rectangle in that positions", "nlp_program": "1) Ignore all pixels that are not part of the rectangles.\n2) Count how many rectangle rows exist from top to bottom. Count how many rectangle columns exist from left to right.\n3) Create an empty output grid with the counted number of rows and the counted number of columns.\n4) For each rectangle position (row i, column j) in the input, set the cell at (row i, column j) in the output to exactly that rectangle’s color.", "variations": ["1) Ignore background noise and isolate all rectangles by their clear edges\n2) Group rectangles into rows by similar vertical position, and into columns by similar horizontal position\n3) Count the groups to determine rows and columns, forming an R by C grid\n4) For each cell in the grid, fill it with the color sampled from the corresponding rectangle", "1) Scan left-to-right and top-to-bottom to list all visible rectangles, skipping noisy artifacts that aren’t rectangular\n2) Split the list into rows whenever the vertical position jumps beyond a small threshold; within each row, order rectangles by horizontal position\n3) Use the number of rows and the largest row length as the grid size\n4) Paint each grid cell with the color of the rectangle found at that row and column", "1) Project the image onto the vertical axis to find column alignments and count columns; project onto the horizontal axis to find row alignments and count rows\n2) At each row–column intersection, locate the dominant rectangle and capture its color\n3) Create an output grid with the detected number of rows and columns\n4) Fill each grid cell using the captured color from its matching position"], "llm_error": null, "all_test_hashes": ["7ea58387"], "timestamp": 1758235026.8913379}
{"task_id": "0a2355a6", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 0], [0, 0, 8, 0, 0, 8, 0, 0, 8, 8, 8, 0, 0, 8, 0, 8, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 0, 8, 0, 0, 8, 8, 8, 0], [0, 0, 0, 0, 8, 0, 8, 0, 8, 0, 8, 0, 0, 8, 0, 8, 0], [0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 0, 0, 8, 0, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 0], [0, 0, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 8, 8, 8, 8, 8, 8, 8], [0, 0, 8, 8, 8, 8, 8, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 8, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8]], "output_hash": "53da68d8", "output_sha1": "c5d8c2f0762526874424f7285527f97e1e4a8277", "ok": false, "insts": ["1) If an obj has 4 holes color it 4\n2) if it has 1 color it 1\n3) if it has 3 color it 2\n4) If it has 2 color it 3"], "insts_text": "1) If an obj has 4 holes color it 4\n2) if it has 1 color it 1\n3) if it has 3 color it 2\n4) If it has 2 color it 3", "nlp_program": "1) For each object in the grid: if it has exactly 1 hole, set all cells of that object to color 1.\n2) For each object in the grid: if it has exactly 2 holes, set all cells of that object to color 3.\n3) For each object in the grid: if it has exactly 3 holes, set all cells of that object to color 2.\n4) For each object in the grid: if it has exactly 4 holes, set all cells of that object to color 4.", "variations": ["1) Assign each object a tentative color equal to its hole count\n2) Recolor every object with 2 holes to color 3\n3) Recolor every object with 3 holes to color 2\n4) Leave objects with 1 or 4 holes as they are", "1) Partition objects into four groups by hole count: 1, 2, 3, and 4\n2) Color the 1-hole group with color 1\n3) Color the 3-hole group with color 2\n4) Color the 2-hole group with color 3\n5) Color the 4-hole group with color 4", "1) Define a mapping from hole count to color: 1→1, 2→3, 3→2, 4→4\n2) For each object, determine its number of holes\n3) Look up the hole count in the mapping and assign the corresponding color"], "llm_error": null, "all_test_hashes": ["58361410"], "timestamp": 1758235336.868031}
{"task_id": "0b148d64", "split": "training", "test_index": 0, "output": [[1, 1, 1, 1, 0, 1], [1, 0, 1, 0, 1, 1], [1, 1, 0, 1, 1, 0], [0, 0, 0, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]], "output_hash": "6a740fd8", "output_sha1": "f2d58e70a8675e4047b629129e60320193e148db", "ok": true, "insts": ["1) You will see 4 objects, 3 of those objects are similarly colored 1 is not. \n2)Take the 1, get the smallest bounding box \n3) output this smallest bounding box, with the object inside as well\n4) Essentially isolating the object with a different color and outputting"], "insts_text": "1) You will see 4 objects, 3 of those objects are similarly colored 1 is not. \n2)Take the 1, get the smallest bounding box \n3) output this smallest bounding box, with the object inside as well\n4) Essentially isolating the object with a different color and outputting", "nlp_program": "1) List the colors of the 4 objects and count how many objects use each color.\n2) Select the single object whose color count equals 1.\n3) Create the smallest axis-aligned rectangle that contains all cells of this selected object (its tight bounding box).\n4) Output only this rectangle: copy all cells inside this rectangle from the input; do not include any cells outside the rectangle.", "variations": ["1) Inspect the four objects and determine the majority color among them\n2) Select the single object whose color does not match the majority\n3) Draw the tightest axis-aligned rectangle that fully encloses this object\n4) Output that rectangle along with the contained object, isolating it", "1) Group the four objects by color similarity and locate the cluster with only one member\n2) From that lone member, find its extreme top, bottom, left, and right extents\n3) Form the minimal bounding rectangle using those extremes\n4) Return just this bounding rectangle including the object inside", "1) Compare each object’s color to the others to find the outlier in hue/saturation\n2) Mask out all objects except the detected outlier\n3) Compute the smallest enclosing box around the visible outlier\n4) Output this minimal box with the outlier object preserved within"], "llm_error": null, "all_test_hashes": ["6a740fd8"], "timestamp": 1758235577.3808959}
{"task_id": "0a938d79", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output_hash": "61eb7e97", "output_sha1": "d477ec2adc860e249c052baf87cd8f4e3f03d3f4", "ok": false, "insts": ["1) In the input grid there are to horizontal or 2 vertical blocks that tart from walls and extend by two blocks. \n2) order the from left to righ, or top to bottom.\n3) Start from the left most or right most verticle object and extend it form a line touching the other wall, do the same for the object, and alternate, keepingt the space. \n4) The key is that the left most original blocks form the starting point of the alternating pattern.  The lines have the same colors as the two original blocks."], "insts_text": "1) In the input grid there are to horizontal or 2 vertical blocks that tart from walls and extend by two blocks. \n2) order the from left to righ, or top to bottom.\n3) Start from the left most or right most verticle object and extend it form a line touching the other wall, do the same for the object, and alternate, keepingt the space. \n4) The key is that the left most original blocks form the starting point of the alternating pattern.  The lines have the same colors as the two original blocks.", "nlp_program": "1) If there are two vertical 2-cell blocks touching a top or bottom wall in single columns, go to step 2. Else (there are two horizontal 2-cell blocks touching a left or right wall in single rows), go to step 6.\n2) Vertical case: Identify the two seed columns: the columns that contain the two vertical 2-cell blocks. Sort these two columns from left to right as seed column A (left) and seed column B (right).\n3) In seed column A and seed column B, copy the block color in each occupied cell to all cells in the same column from the top wall to the bottom wall (make each seed column a full vertical line of its color).\n4) Compute the spacing S as the number of empty columns strictly between seed column A and seed column B. (Example: if A is column 2 and B is column 5, then S = 2 because columns 3-4 are between.)\n5) Fill the entire grid with vertical lines using spacing S and alternating the two seed colors: starting at seed column A, move right by (S+1) columns repeatedly and set each of those columns to the color of seed column A; starting at seed column B, move right by (S+1) columns repeatedly and set each of those columns to the color of seed column B. Stop when you pass the last column.\n6) Horizontal case: Identify the two seed rows: the rows that contain the two horizontal 2-cell blocks. Sort these two rows from top to bottom as seed row A (top) and seed row B (bottom).\n7) In seed row A and seed row B, copy the block color in each occupied cell to all cells in the same row from the left wall to the right wall (make each seed row a full horizontal line of its color).\n8) Compute the spacing S as the number of empty rows strictly between seed row A and seed row B.\n9) Fill the entire grid with horizontal lines using spacing S and alternating the two seed colors: starting at seed row A, move down by (S+1) rows repeatedly and set each of those rows to the color of seed row A; starting at seed row B, move down by (S+1) rows repeatedly and set each of those rows to the color of seed row B. Stop when you pass the last row.", "variations": ["1) Detect whether the two given starter blocks are horizontal or vertical and which walls they touch.\n2) Measure the gap between the two starters along their orientation and sort them by position (left-to-right or top-to-bottom).\n3) Use the earlier starter as the phase reference, then tile the grid along that axis with full-length lines that match each starter’s color, repeating the measured spacing.\n4) Extend the original two blocks to the opposite wall and continue alternating colors at the same interval until the far wall is reached.", "1) Identify the axis by checking if the two initial blocks run parallel to the top/bottom or left/right walls.\n2) Take the two-block segment that is closest to the origin (top-left in reading order) as the anchor and note the distance to the other segment.\n3) Replicate the anchored segment’s line across the grid at a fixed stride equal to that distance, alternating with the other segment’s color each step.\n4) Convert each replicated position into a solid line from its starting wall to the opposite wall, preserving the alternation and the original colors.", "1) Determine if the seed pair forms vertical columns or horizontal rows, and list them from the near wall outward.\n2) Set the first listed seed as the starting phase and compute the periodicity from the separation between the two seeds.\n3) Perform a sweep from the starting wall: place a full-length line of the first seed’s color, skip a band equal to the period, place a full-length line of the second seed’s color, and repeat.\n4) Continue the sweep, alternating colors and preserving the period, until the lines reach the opposite wall; the colors exactly match those of the two original seeds."], "llm_error": null, "all_test_hashes": ["fcb2440b"], "timestamp": 1758235732.3228629}
{"task_id": "0b17323b", "split": "training", "test_index": 0, "output": [[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output_hash": "c35affb3", "output_sha1": "3968bbe9e2456fc3b286b2f5400df167b2329d62", "ok": false, "insts": ["1) Fiish the diagonal by placing block along the diagonal witht he same spacing as already existing blocks ont he diagonal. \n2) Color the new blocks 2(save the old color blocks)\n3) Output this"], "insts_text": "1) Fiish the diagonal by placing block along the diagonal witht he same spacing as already existing blocks ont he diagonal. \n2) Color the new blocks 2(save the old color blocks)\n3) Output this", "nlp_program": "1) Keep all existing blocks and their colors unchanged.\n2) For each cell on the main diagonal (row 1, column 1; row 2, column 2; row 3, column 3; continue the same way across the grid): if the cell is empty, place a block there and set its color to 2.\n3) Do not change any cells that are not on the main diagonal.\n4) Output the grid.", "variations": ["1) Determine the diagonal’s spacing and direction from the existing blocks, then complete the diagonal by placing missing blocks at the same intervals across the grid.\n2) Assign color 2 to only the newly added blocks, leaving all original block colors unchanged.\n3) Output the result.", "1) Compute the best-fit line through the current diagonal blocks and derive the repeating step; populate all positions along this line at that step, adding blocks where none exist.\n2) Color the added blocks with color 2, preserving the colors of the pre-existing blocks.\n3) Output this.", "1) Starting at the earliest and latest blocks along the diagonal, extend in both directions using the established spacing, inserting blocks wherever gaps occur until the boundary is reached.\n2) Mark every inserted block as color 2 without altering the colors of the original diagonal blocks.\n3) Produce the output."], "llm_error": null, "all_test_hashes": ["b28747b7"], "timestamp": 1758235754.4494874}
{"task_id": "0bb8deee", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 3, 3, 0], [0, 0, 2, 2, 0, 0, 1, 0, 0, 0, 3, 3, 0], [0, 0, 2, 0, 0, 0, 1, 0, 0, 3, 0, 0, 0], [0, 2, 0, 2, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0], [0, 0, 6, 6, 0, 0, 1, 0, 0, 4, 0, 4, 0], [0, 6, 0, 6, 0, 0, 1, 0, 0, 0, 4, 0, 0], [0, 6, 6, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]], "output_hash": "ab8982ae", "output_sha1": "68a1bc2cfe86b5393a5e3619d1a3bbbd9da853cc", "ok": false, "insts": ["1) You will see 4 shapes seperated by a grid\n2) The smallest bounding box is 3 by 3 for each object\n3) place them in a 6 by 6 grid by their order, so they are right next to each other. \n4) Output this grid"], "insts_text": "1) You will see 4 shapes seperated by a grid\n2) The smallest bounding box is 3 by 3 for each object\n3) place them in a 6 by 6 grid by their order, so they are right next to each other. \n4) Output this grid", "nlp_program": "1) Create an empty 6x6 output grid.\n2) Copy all cells from the provided 3x3 bounding box of Shape 1 into output rows 1-3, columns 1-3 (same values, same relative positions).\n3) Copy all cells from the provided 3x3 bounding box of Shape 2 into output rows 1-3, columns 4-6.\n4) Copy all cells from the provided 3x3 bounding box of Shape 3 into output rows 4-6, columns 1-3.\n5) Copy all cells from the provided 3x3 bounding box of Shape 4 into output rows 4-6, columns 4-6.\n6) Output the 6x6 grid.", "variations": ["1) Identify the 4 shapes that are separated by the grid\n2) Crop each shape to its tight 3 by 3 bounding area\n3) Prepare an empty 6 by 6 canvas\n4) Place shapes 1 and 2 in the top row as adjacent 3 by 3 blocks, and shapes 3 and 4 in the bottom row the same way\n5) Output the 6 by 6 result", "1) Read the four shapes in their given order (left-to-right, top-to-bottom)\n2) Normalize each to exactly 3 by 3 by cropping or padding as needed\n3) Horizontally join shapes 1 and 2 to form a 6 by 3 top strip, and shapes 3 and 4 to form a 6 by 3 bottom strip\n4) Stack the two strips to yield a 6 by 6 grid with the shapes adjacent\n5) Output this assembled grid", "1) Partition a 6 by 6 target grid into four non-overlapping 3 by 3 cells\n2) Map the four shapes, in sequence, to the cells: top-left, top-right, bottom-left, bottom-right\n3) For each shape, extract its 3 by 3 bounding contents and copy into the assigned cell without gaps\n4) Produce the final 6 by 6 grid as output"], "llm_error": null, "all_test_hashes": ["a284d58c"], "timestamp": 1758235884.8913734}
{"task_id": "0becf7df", "split": "training", "test_index": 0, "output": [[8, 9, 0, 0, 0, 0, 0, 0, 0, 0], [2, 4, 0, 0, 0, 9, 9, 0, 0, 0], [0, 0, 0, 8, 8, 8, 9, 0, 0, 0], [0, 0, 0, 2, 8, 8, 9, 0, 0, 0], [0, 0, 0, 2, 4, 2, 0, 0, 0, 0], [0, 0, 0, 2, 2, 4, 0, 0, 0, 0], [0, 0, 0, 2, 4, 4, 0, 0, 0, 0], [0, 0, 0, 9, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output_hash": "9a36ca10", "output_sha1": "c7969925b2be837539b16b168d07070da7c65342", "ok": false, "insts": ["1) You will se a square in the top with 4 different colors. Keep the square exactly as is in the output grid \n2) The square is a 2 by 2 grid, taake the two top block and two bottom blocks. Map the between them. As teh square has unique colors on each block,  for the two top 1, 1 and <=>1,2 color wise and the same for the bottom row\n3) There is a second object, simply map each color based on step 2 to its corresponding color"], "insts_text": "1) You will se a square in the top with 4 different colors. Keep the square exactly as is in the output grid \n2) The square is a 2 by 2 grid, taake the two top block and two bottom blocks. Map the between them. As teh square has unique colors on each block,  for the two top 1, 1 and <=>1,2 color wise and the same for the bottom row\n3) There is a second object, simply map each color based on step 2 to its corresponding color", "nlp_program": "1) Copy the 2x2 square in rows 1-2, columns 1-2 from input to the same positions in the output.\n2) Create a color mapping using the 2x2 square:\n   - Map the color in row 1, column 1 to the color in row 1, column 2.\n   - Map the color in row 1, column 2 to the color in row 1, column 1.\n   - Map the color in row 2, column 1 to the color in row 2, column 2.\n   - Map the color in row 2, column 2 to the color in row 2, column 1.\n3) For every cell outside rows 1-2, columns 1-2: replace its color using the mapping from step 2; if the cell’s color is not one of the four mapped colors, leave it unchanged.", "variations": ["1) Locate the 2 by 2 color key at the top and preserve it exactly in the output\n2) For each row of the key, pair the left cell’s color with the right cell’s color, and pair the right back to the left\n3) Recolor the second object by replacing each of its colors according to these pairs, leaving the key unchanged", "1) Identify the top 2x2 square and keep it unmodified in the final grid\n2) Establish a row-wise swap: within each row of the square, map column 1’s color to column 2’s color, and column 2’s color to column 1’s color\n3) Apply this swap to every cell of the other object only", "1) Treat the top 2×2 as a legend and copy it as-is to the output\n2) Create two independent swaps, one per row of the legend, that exchange the two colors in that row (no mixing between rows)\n3) Transform the colors of the second shape using these swaps while leaving the legend intact"], "llm_error": null, "all_test_hashes": ["1aba13ce"], "timestamp": 1758236452.9295905}
{"task_id": "0c786b71", "split": "training", "test_index": 0, "output": [[8, 5, 7, 8], [7, 7, 8, 8], [5, 5, 8, 5]], "output_hash": "f33ce2ed", "output_sha1": "b7ec9ffbd0779378b1f174e202be758e37d52e31", "ok": false, "insts": ["1) Take the input grid\n2) reflect it vertically(acorss a verticle line), join these grids. \n3) reflect the now joined grid acorss a horrizontal line\n4) output this, if the input is 3 * 4 the output should be 6 * 6. We are simply reflecting, like opening up a piece of continuously halved paper(while reflecting each time)"], "insts_text": "1) Take the input grid\n2) reflect it vertically(acorss a verticle line), join these grids. \n3) reflect the now joined grid acorss a horrizontal line\n4) output this, if the input is 3 * 4 the output should be 6 * 6. We are simply reflecting, like opening up a piece of continuously halved paper(while reflecting each time)", "nlp_program": "1) Start with the input grid.\n2) Create a left-right mirror of the input: for each row, reverse the order of its columns to make a mirrored copy.\n3) Place the original grid on the left and the left-right mirrored copy on the right; align row 1 with row 1, row 2 with row 2, etc. This makes a grid with the same number of rows as the input and twice the columns.\n4) Create a top-bottom mirror of the grid from step 3: reverse the order of its rows to make a mirrored copy.\n5) Place the grid from step 3 on the top and its top-bottom mirrored copy on the bottom; align column 1 with column 1, column 2 with column 2, etc.\n6) Output the resulting grid.", "variations": ["1) Take the input grid\n2) Place a left-right mirrored copy to its right\n3) Place a top-bottom mirrored copy of the new wide grid beneath it\n4) Output the final grid; both height and width are doubled", "1) Take the input grid\n2) Stack beneath it a top-bottom mirrored copy\n3) Reflect this tall stack left-right and place it to the right\n4) Output the combined grid with dimensions doubled in both directions", "1) Take the input grid\n2) Prepare four quadrants: TL = original, TR = left-right mirror, BL = top-bottom mirror, BR = both mirrors\n3) Join them as a 2 by 2 block: TL next to TR on top, BL next to BR on bottom\n4) Output the assembled grid; size is doubled horizontally and vertically"], "llm_error": null, "all_test_hashes": ["65a07030"], "timestamp": 1758236753.9890425}
{"task_id": "0c9aba6e", "split": "training", "test_index": 0, "output": [[0, 0, 0, 2], [0, 2, 2, 0], [2, 0, 0, 2], [0, 2, 2, 0], [2, 0, 2, 2], [0, 0, 0, 2], [7, 7, 7, 7], [6, 6, 0, 6], [6, 6, 6, 0], [0, 0, 0, 0], [6, 6, 0, 6], [6, 0, 6, 0], [0, 0, 6, 6]], "output_hash": "6b96ba7c", "output_sha1": "3fbb8e7c300deffe96490a52727f05dd7464f8dc", "ok": false, "insts": ["1) Take the two halves(divided by a horizontal line)\n2) Get the intersection, where both halves are zero color 8, if not both zero color 0. \n3) Return this overlapped area as a grid(halves are say 6 * 4 return a 6 * 4 grid)"], "insts_text": "1) Take the two halves(divided by a horizontal line)\n2) Get the intersection, where both halves are zero color 8, if not both zero color 0. \n3) Return this overlapped area as a grid(halves are say 6 * 4 return a 6 * 4 grid)", "nlp_program": "1) Count the total number of rows. Divide by 2 to get H. Let W be the total number of columns.\n2) Create an empty output grid with H rows and W columns.\n3) For each row r from 1 to H, and each column c from 1 to W:\n   - If the cell at (r, c) equals 0 and the cell at (r+H, c) equals 0, set output (r, c) to 8.\n   - Otherwise, set output (r, c) to 0.\n4) Return the H-by-W output grid.", "variations": ["1) Split the grid into top and bottom halves along the horizontal divider\n2) For each half, create a same-sized mask: mark 1 where the cell is color 0, otherwise 0\n3) Combine the two masks by elementwise multiplication\n4) Convert 1s to color 8 and 0s to color 0, and output the half-sized grid", "1) Partition the grid into equal upper and lower halves\n2) Create an output grid matching the half dimensions, initialized to color 0\n3) For each position, if both the upper and lower cells are color 0, set the output cell to color 8; otherwise keep it at color 0\n4) Return the resulting grid", "1) Divide the grid horizontally into two equal halves\n2) Make a union map of nonzero cells: mark positions that are nonzero in at least one half\n3) Invert this map within the half-sized area to identify positions where both halves are zero\n4) Fill those positions with color 8 and all others with color 0, and output the half-sized grid"], "llm_error": null, "all_test_hashes": ["6f5f2844"], "timestamp": 1758237259.3397954}
{"task_id": "0ca9ddb6", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output_hash": "74416903", "output_sha1": "ee9b277904f3ce019831939c2fa151146b5238ac", "ok": false, "insts": ["1) For blocks in the input with a no 2 color create an X from the block coloring the diagonal(1 block in eac diagonal direction) while keeping the middle block color.\n2) For the blocks with a color 1, create a cross(up, down ...) with color 7, while keeping the middle 1 color) \n3) For any other blocks with a different color, leave them, they should remain single blocks, in the output grid."], "insts_text": "1) For blocks in the input with a no 2 color create an X from the block coloring the diagonal(1 block in eac diagonal direction) while keeping the middle block color.\n2) For the blocks with a color 1, create a cross(up, down ...) with color 7, while keeping the middle 1 color) \n3) For any other blocks with a different color, leave them, they should remain single blocks, in the output grid.", "nlp_program": "1) Copy the entire input grid to the output grid, same positions.\n2) For each cell in the input with value 2: in the output, set the four diagonal neighbors (row-1/col-1, row-1/col+1, row+1/col-1, row+1/col+1) to value 2 if those positions are inside the grid. Leave the center cell unchanged.\n3) For each cell in the input with value 1: in the output, set the four orthogonal neighbors (row-1/same col, row+1/same col, same row/col-1, same row/col+1) to value 7 if those positions are inside the grid. Leave the center cell as value 1.\n4) Do not change any other cells in the output.", "variations": ["1) For each cell colored 2, draw an X around it by coloring the four diagonal adjacent cells with 2, leaving the center unchanged.\n2) For each cell colored 1, draw a plus around it by coloring the four orthogonal adjacent cells with 7, leaving the center as 1.\n3) All other colors remain as isolated single cells.", "1) Transform every occurrence of color 2 into a five-cell X: keep the center as is and set the four diagonals to color 2.\n2) Transform every occurrence of color 1 into a five-cell cross: keep the center as 1 and set up/down/left/right to color 7.\n3) Any cell of a different color does not expand and stays single.", "1) Using the locations of color 2 as seeds, grow diagonal arms one step in all four diagonal directions with color 2, preserving each seed’s original color at the center.\n2) Using the locations of color 1 as seeds, grow orthogonal arms one step in all four cardinal directions with color 7, preserving the center as 1.\n3) Ignore all other colors; they remain unchanged."], "llm_error": null, "all_test_hashes": ["7e878d3f"], "timestamp": 1758237424.249848}
{"task_id": "0d3d703e", "split": "training", "test_index": 0, "output": [[8, 1, 3], [8, 1, 3], [8, 1, 3]], "output_hash": "e88bd4b4", "output_sha1": "7f460088deb645e80527223021f4e54e852da60f", "ok": false, "insts": ["1) Simple color mapping \n5 <=> 1\n8 <=> 9\n6 <=> 2\n3 <=> 4\n2) Take this ordering and swap the colors for the output grid, everything else remains the same."], "insts_text": "1) Simple color mapping \n5 <=> 1\n8 <=> 9\n6 <=> 2\n3 <=> 4\n2) Take this ordering and swap the colors for the output grid, everything else remains the same.", "nlp_program": "1) Start with the input grid. Create an empty output grid of the same size.\n2) For each cell at row r, column c in the input grid, do the following checks in order and write to the same row r, column c in the output grid:\n   - If the value equals 5, write 1.\n   - Else if the value equals 1, write 5.\n   - Else if the value equals 8, write 9.\n   - Else if the value equals 9, write 8.\n   - Else if the value equals 6, write 2.\n   - Else if the value equals 2, write 6.\n   - Else if the value equals 3, write 4.\n   - Else if the value equals 4, write 3.\n   - Else write the original value.\n3) Repeat step 2 for all rows and all columns until every cell is processed.\n4) Output the completed output grid.", "variations": ["1) Pairwise swap specification\n5 <=> 1\n8 <=> 9\n6 <=> 2\n3 <=> 4\n2) Traverse the grid and flip each cell’s color according to these pairs; keep all geometry and positions unchanged.", "1) Apply permutation cycles: (1 5), (8 9), (2 6), (3 4)\n2) For every cell, substitute its color with the partner from its cycle; everything else stays the same.", "1) Two-pass relabel using placeholders\nFirst pass: 1->A, 5->B, 8->C, 9->D, 2->E, 6->F, 3->G, 4->H\nSecond pass: A->5, B->1, C->9, D->8, E->6, F->2, G->4, H->3\n2) Apply the relabeling to the grid; any color not mentioned remains unchanged."], "llm_error": null, "all_test_hashes": ["aa1132c6"], "timestamp": 1758237676.9318345}
{"task_id": "0d87d2a6", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 2, 2, 2, 0, 0, 2, 2, 2, 0, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 0, 0], [1, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 0, 1], [0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 2, 2, 2, 2, 2, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 2, 2, 0, 0, 2, 2, 2, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output_hash": "0bfc7d5e", "output_sha1": "e4d88c4f052f68e982c56508bd716866a516d0d1", "ok": false, "insts": ["1) There are large rectangles of color 2 and small 1 size blcoks at the wall of color 1. \n2) Connect the 1 size blocks to its direclty vertical or horizontal counterpart. \n3) While connecting keep the color of the 1 size block and any other object that is touched by this connector turns to color 1.\n4) Everything else remain the same from the input grid, and output"], "insts_text": "1) There are large rectangles of color 2 and small 1 size blcoks at the wall of color 1. \n2) Connect the 1 size blocks to its direclty vertical or horizontal counterpart. \n3) While connecting keep the color of the 1 size block and any other object that is touched by this connector turns to color 1.\n4) Everything else remain the same from the input grid, and output", "nlp_program": "1) Copy the entire input grid to the output grid unchanged.\n2) Treat row 1, the last row, column 1, and the last column as the border.\n3) For each border cell with value equals 1:\n   3.1) Up: In the same column, scan rows above toward row 1. If you encounter another border cell with value equals 1, stop at the first such cell. Set every cell from the starting cell to that cell (inclusive) in that column to value 1.\n   3.2) Down: In the same column, scan rows below toward the last row. If you encounter another border cell with value equals 1, stop at the first such cell. Set every cell from the starting cell to that cell (inclusive) in that column to value 1.\n   3.3) Left: In the same row, scan columns left toward column 1. If you encounter another border cell with value equals 1, stop at the first such cell. Set every cell from the starting cell to that cell (inclusive) in that row to value 1.\n   3.4) Right: In the same row, scan columns right toward the last column. If you encounter another border cell with value equals 1, stop at the first such cell. Set every cell from the starting cell to that cell (inclusive) in that row to value 1.\n4) Leave all other cells as they are in the output grid.", "variations": ["1) The grid contains large rectangles of color 2 and single-cell color 1 blocks along the border.\n2) Grow each wall 1 outward orthogonally (up, down, left, right) using Manhattan expansion until it meets its directly aligned counterpart.\n3) As the growth passes through cells or objects, turn them to color 1; when two expansions meet, the connector is fixed as color 1.\n4) Leave all untouched cells exactly as in the input grid, and output.\n\n1) Identify the single-cell color 1 blocks on the walls; acknowledge the presence of large color 2 rectangles elsewhere.\n2) For every pair of wall 1s that lie on the same row or the same column, draw a straight connector along that line choosing the shortest orthogonal segment between them.\n3) Any cell or object crossed by a connector becomes color 1; overlapping connectors remain color 1.\n4) Do not modify any other part of the grid, and output.\n\n1) Note the big color 2 rectangles and the wall-adjacent single color 1 blocks.\n2) From each wall 1, cast rays in the four orthogonal directions; when a ray encounters another wall 1 on the same line, commit the entire segment between them as the connection.\n3) Recolor every cell and any object touched by a committed segment to color 1; ignore rays that do not reach another wall 1.\n4) Preserve everything else from the input grid, and output."], "llm_error": null, "all_test_hashes": ["34aa68bd"], "timestamp": 1758237814.0478306}
{"task_id": "0e206a2e", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 1, 5, 5, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output_hash": "319260e9", "output_sha1": "3a5e421a5415be38321e36ef76f9bf491f8a5fb0", "ok": false, "insts": ["1) You will see  contingous objs, and the same number of  sets, in each set there are disconnected blocks\n2) These disconnected blocks are the contigous objs but portions of them. Translated and reflected by some amount. \n3) For each set take the cont objs and translate and reflect them until you find a match in the contig objs. \n4) The output should be the matches and nothign else, essentially you translate and reflect the contingous objs until they match with one of the disconnected sets int the grid and keep this"], "insts_text": "1) You will see  contingous objs, and the same number of  sets, in each set there are disconnected blocks\n2) These disconnected blocks are the contigous objs but portions of them. Translated and reflected by some amount. \n3) For each set take the cont objs and translate and reflect them until you find a match in the contig objs. \n4) The output should be the matches and nothign else, essentially you translate and reflect the contingous objs until they match with one of the disconnected sets int the grid and keep this", "nlp_program": "1) Make an empty output grid the same size as the input grid. Set every cell in the output to 0.\n2) Treat each group of disconnected blocks as one set. Treat each whole connected shape as one contiguous object.\n3) For each set, do steps 4–7.\n4) For each contiguous object, do steps 5–7.\n5) Make four versions of the contiguous object: (a) no flip, (b) flip left-right, (c) flip up-down, (d) flip both left-right and up-down.\n6) For each version in step 5, slide it across the grid one cell at a time in rows 1 to last row and columns 1 to last column, only using positions where every cell of the version stays inside the grid.\n7) At each position from step 6, check this exact condition: every filled cell of the moved version is on a filled cell of the set, and every filled cell of the set is covered by the moved version. If this condition is true, set those exact cells (the set’s filled cells) to 1 in the output in the same row and column positions. Leave all other output cells unchanged.", "variations": ["1) You are given a collection of whole shapes and an equal number of groups composed of separated fragments\n2) Each group’s fragments are pieces of one whole shape, moved and mirrored relative to the original\n3) For each whole shape, normalize it to an anchor (e.g., top-left pixel) and mirror variants, then align by translation to each group’s fragments to test correspondence\n4) Keep only the pairings where a mirrored-and-translated whole shape coincides exactly with a group’s fragments, and output those matches", "1) Observe multiple intact figures and the same number of fragment groups scattered in the grid\n2) The fragment groups are cut-outs of the intact figures, shifted and possibly reflected\n3) Reassemble each fragment group by translating fragments into a common frame; compare against reflected copies of every intact figure to find an exact reconstruction\n4) Output only the successful reconstructions, i.e., the intact figure matched to its fragment group", "1) Identify all connected components (the complete objects) and list an equal count of fragment sets composed of disjoint pieces\n2) Each fragment set corresponds to one connected component under some translation and reflection of its parts\n3) Generate reflection variants of each connected component and compute position-invariant shape signatures; translate candidates to overlay with fragment sets and test for exact coverage\n4) Report only the overlays that perfectly cover a fragment set with one reflected-and-translated connected component, omitting everything else"], "llm_error": null, "all_test_hashes": ["d87df01b"], "timestamp": 1758238240.8175426}
{"task_id": "0e671a1a", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output_hash": "b634c659", "output_sha1": "c97a5628178afdf4e8ca93fdfb2cd1ea9f75d0dc", "ok": false, "insts": ["1) there are 3 blocks colored no 3, 2, 4. \n2) Connect the 3 -> 4, 4 -> 2. The color of the connected line must be 5. \n3) The connecting line should only have verticle and horizontal parts. From block with the color 3 you should start by going vertically and then horizontally, for the connection between 4 and 2 you should also do the same(starts verticle form 4 and goes horizontal), find the shortest path that starts from vertical and goes horizontal."], "insts_text": "1) there are 3 blocks colored no 3, 2, 4. \n2) Connect the 3 -> 4, 4 -> 2. The color of the connected line must be 5. \n3) The connecting line should only have verticle and horizontal parts. From block with the color 3 you should start by going vertically and then horizontally, for the connection between 4 and 2 you should also do the same(starts verticle form 4 and goes horizontal), find the shortest path that starts from vertical and goes horizontal.", "nlp_program": "1) Locate the three blocks: one with color value 3, one with color value 4, and one with color value 2.\n2) Connect block 3 to block 4 using color 5: starting at the center of block 3, draw a straight vertical line toward block 4 until the row of the line matches the row of block 4; then draw a straight horizontal line to reach the center of block 4. Use only vertical and horizontal segments.\n3) Connect block 4 to block 2 using color 5: starting at the center of block 4, draw a straight vertical line toward block 2 until the row of the line matches the row of block 2; then draw a straight horizontal line to reach the center of block 2. Use only vertical and horizontal segments.\n4) Do not add any diagonal segments. Ensure all drawn segments have color value 5.", "variations": ["1) Place three nodes labeled with colors 3, 2, and 4.\n2) Draw links connecting 3 to 4 and 4 to 2; use color 5 for both links.\n3) Each link must be an orthogonal L-shape: start with a vertical segment from the source node, then turn and go horizontal to the target. Among all such vertical-then-horizontal routes, choose the shortest.", "1) Set up three markers: one colored 3, one colored 2, and one colored 4.\n2) Route two paths: one from 3→4 and another from 4→2, and color the paths with 5.\n3) Paths may only move along grid axes, beginning vertically and then horizontally for each connection. Select the minimum Manhattan-length path satisfying the vertical-first rule.", "1) Define blocks with labels 3, 2, and 4.\n2) Connect the pairs (3,4) and (4,2) using lines of color 5.\n3) Lines must be composed solely of vertical and horizontal segments; for each connection, take a vertical step out of the source, then complete the remainder horizontally. Use the shortest possible vertical-then-horizontal route."], "llm_error": null, "all_test_hashes": ["f9040ec2"], "timestamp": 1758238518.8699608}
{"task_id": "0f63c0b9", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output_hash": "af5394fe", "output_sha1": "681f602aed59d4db170cfcafdc32deca3ea6862c", "ok": false, "insts": ["1) Create an output grid of the same size and a border around it, intitially colro 0. \n2) There are blocks in the input grid, extend the blocks using a line horizontally, the line has the same color as the block. \n3)When it touches the border, the border should have the same color.\n 4) Repeat for each block following the top to bottom direction \n5) Now there are horizontal bands and a border, the border should be colored by the closes horizontal bands color. If the distance is the same then the topmost horizontal bands color. \n4) Return this"], "insts_text": "1) Create an output grid of the same size and a border around it, intitially colro 0. \n2) There are blocks in the input grid, extend the blocks using a line horizontally, the line has the same color as the block. \n3)When it touches the border, the border should have the same color.\n 4) Repeat for each block following the top to bottom direction \n5) Now there are horizontal bands and a border, the border should be colored by the closes horizontal bands color. If the distance is the same then the topmost horizontal bands color. \n4) Return this", "nlp_program": "1) Create an output grid with an extra border of width 1 around the input. Set all cells in the output to 0.\n2) Copy each input cell at (row r, column c) into output at (row r+1, column c+1).\n3) For rows 2 to last row−1 (top to bottom) and columns 2 to last column−1 (left to right):\n   - If the cell value equals v and v > 0:\n     a) Extend left: move one column left at a time in the same row until column 1. For each visited cell:\n        - If its value equals 0, set it to v.\n        - If its value does not equal 0 and does not equal v, stop before this cell.\n     b) Extend right: move one column right at a time in the same row until the last column. For each visited cell:\n        - If its value equals 0, set it to v.\n        - If its value does not equal 0 and does not equal v, stop before this cell.\n4) Color the border by the closest band along straight lines:\n   - Top border (row 1, columns 1 to last column): for each column, scan downward from row 2 to last row. If the first non‑0 value equals x, set the border cell to x; if none found, leave it 0.\n   - Bottom border (last row, columns 1 to last column): for each column, scan upward from last row−1 to row 1. If the first non‑0 value equals x, set the border cell to x; if none found, leave it 0.\n   - Left border (column 1, rows 1 to last row): for each row, scan rightward from column 2 to last column. If the first non‑0 value equals x, set the border cell to x; if none found, leave it 0.\n   - Right border (last column, rows 1 to last row): for each row, scan leftward from last column−1 to column 1. If the first non‑0 value equals x, set the border cell to x; if none found, leave it 0.\n5) Return the output grid.", "variations": ["1) Initialize an output grid with the same dimensions as the input and surround it with a border colored 0.\n2) Process the grid row by row from top to bottom. In each row, locate every contiguous block segment and extend that segment horizontally in both directions until the left and right borders are reached, using the segment’s color.\n3) When an extension reaches a border cell, color that border cell with the same color as the segment that touched it.\n4) If two horizontal extensions meet inside a row, keep the color from the nearer segment; if the distances are equal, prefer the color from the segment in the higher row.\n5) After all rows are extended, set each cell of the top and bottom borders to the color of the nearest horizontal band by vertical distance; if the distance is the same to two bands, choose the color of the upper band.\n6) Return the resulting grid.", "1) Create an output grid matching the input’s size and add a border initialized to color 0.\n2) Perform simultaneous horizontal growth from every block: in each time step, expand one cell left and one cell right from every block or grown cell of the same color, but only within its row.\n3) Continue growing until no further horizontal expansion is possible or the borders are reached; whenever growth touches the border, paint the touched border cell with that color immediately.\n4) If competing colors try to occupy the same cell in the same step, assign the cell to the color whose source band is vertically higher; if still tied, keep the current color.\n5) For any top or bottom border cell not touched during growth, assign it the color of the nearest horizontal band below/above by vertical distance; if equally distant, use the color of the upper band.\n6) Return the final grid.", "1) Start with an output grid of identical size to the input and surround it with a border set to color 0.\n2) For each distinct block, cast two horizontal rays: one moving left and one moving right along its row. Paint every unpainted cell encountered with the block’s color until a border is reached.\n3) When a ray contacts the border, color that specific border cell with the ray’s color.\n4) If a ray attempts to color a cell already painted by another ray, keep the color whose originating block is closer in horizontal distance; if distances match, choose the color from the block located in the higher row.\n5) After all rays finish, go over the top and bottom borders and recolor each border cell to the color of the vertically closest horizontal band; on ties, select the color from the upper band.\n6) Return the completed grid."], "llm_error": null, "all_test_hashes": ["f3242361"], "timestamp": 1758239095.8024404}
{"task_id": "103eff5b", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2, 0, 0], [0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 0], [0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output_hash": "afdc563b", "output_sha1": "e5c63c4a89fce11f919929b01141007ce6333d91", "ok": false, "insts": ["1) Simply rotate the small object clockwise by 90 degrees\n2) Now the small object should be identical to the large object if you scale, so scale and color the large object using he corresponding colors of the small object \n3) Output the same small object as the input, but the large object now is colored."], "insts_text": "1) Simply rotate the small object clockwise by 90 degrees\n2) Now the small object should be identical to the large object if you scale, so scale and color the large object using he corresponding colors of the small object \n3) Output the same small object as the input, but the large object now is colored.", "nlp_program": "1) Make a temporary copy of the small object.\n2) Rotate the temporary copy 90 degrees clockwise around its center.\n3) Uniformly scale the temporary copy so its width equals the large object's width and its height equals the large object's height.\n4) Align the top-left corner of the temporary copy with the top-left corner of the large object.\n5) For every row and column inside the large object's bounds, set the color of the large object's cell at that row and column to the color of the temporary copy's cell at the same row and column.\n6) Output the original small object unchanged and the large object colored as set in step 5.", "variations": ["1) Rotate the large object 90 degrees counterclockwise and scale it down to match the small object\n2) Copy colors from the small object onto the aligned large object, part by part\n3) Return the large object to its original size and orientation, and output it colored while keeping the small object unchanged", "1) Without rotating either object, segment both shapes into corresponding parts based on geometry\n2) Map each segment of the large object to the matching segment of the small object and assign the same color\n3) Output the original small object and the large object now recolored", "1) Mirror the small object horizontally and rotate it 90 degrees counterclockwise to match the large object’s layout\n2) Scale this aligned small-object template to the large object’s bounds and use it as a stencil to paint the large object with corresponding colors\n3) Restore the small object to its original state for output, leaving the large object colored"], "llm_error": null, "all_test_hashes": ["c86a9eab"], "timestamp": 1758239541.0435946}
{"task_id": "11852cab", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 4, 0, 1, 0, 0, 0, 0], [0, 0, 2, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 2, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output_hash": "0a13b94d", "output_sha1": "1918c19e7198eab7046a3948ec1d32c97ad7d7ca", "ok": false, "insts": ["1) In the input grid there is some symmetrical object, with 1 asymmetrical block.\n2) Make this symmetrical by rotating it 90 degrees clockwise until it return to the same spot, return the full object. AS it is now fully symmetrical"], "insts_text": "1) In the input grid there is some symmetrical object, with 1 asymmetrical block.\n2) Make this symmetrical by rotating it 90 degrees clockwise until it return to the same spot, return the full object. AS it is now fully symmetrical", "nlp_program": "1) Create an output grid with the same size as the input. Copy all cell values from the input to the output.\n2) Make a 90-degree clockwise rotated copy of the entire input grid. For every row and column: if the rotated cell value equals 1, set the output cell at the same row and column to 1.\n3) Make a 180-degree rotated copy of the entire input grid. For every row and column: if the rotated cell value equals 1, set the output cell at the same row and column to 1.\n4) Make a 270-degree clockwise rotated copy of the entire input grid. For every row and column: if the rotated cell value equals 1, set the output cell at the same row and column to 1.\n5) Return the output grid.", "variations": ["1) Identify the object in the grid and its rotational center.\n2) Produce the object’s 0°, 90°, 180°, and 270° rotations around that center.\n3) Combine all rotated versions into a single shape by merging their occupied cells.\n4) Return the merged shape as the fully symmetrical object.", "1) Locate the object and its central point.\n2) Reflect the object across the vertical axis through the center and merge with the original.\n3) Reflect the result across the horizontal axis through the center and merge again.\n4) Return the final merged object, now symmetric in all quadrants.", "1) Find the object’s center and compare cells related by 90° rotation.\n2) Detect the single block that lacks a rotational counterpart.\n3) Place matching blocks at the three rotated positions corresponding to that block.\n4) Return the completed object with four-fold rotational symmetry."], "llm_error": null, "all_test_hashes": ["dd2ce559"], "timestamp": 1758240975.6816194}
{"task_id": "1190bc91", "split": "training", "test_index": 0, "output": [[0, 0, 0, 9, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 7], [0, 0, 4, 0, 0, 0, 0, 7], [0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 6, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0]], "output_hash": "da363063", "output_sha1": "2ad1323a680e6d720b989de48bcbd80a00f3fc1c", "ok": false, "insts": ["1) Find the vertical bar, that extends fromt he wall outwards. \n2) Get the top most block in the bar and extend diagonally in each diagonal direction. until the extension hits another block. \n3) Do this for the next block in the vertical bar, respecting previous extensions and blocks. \n4) Once done go to the veritcal bars that lie along the wall rather than extend from it, color the surrounding adjacent region, with no blocks(0 color), using the color of this  vertical  bar along the wall. \n5) Return this grid"], "insts_text": "1) Find the vertical bar, that extends fromt he wall outwards. \n2) Get the top most block in the bar and extend diagonally in each diagonal direction. until the extension hits another block. \n3) Do this for the next block in the vertical bar, respecting previous extensions and blocks. \n4) Once done go to the veritcal bars that lie along the wall rather than extend from it, color the surrounding adjacent region, with no blocks(0 color), using the color of this  vertical  bar along the wall. \n5) Return this grid", "nlp_program": "1) Treat any cell with value 0 as empty. Treat any cell with value >0 as a block whose color equals its value.\n2) Process vertical bars that extend from the top or bottom wall:\n   a) For rows 1 to last row and for each column, when you see a maximal run of consecutive non-zero cells in that column that touches row 1 or touches the last row, mark it as one vertical bar for this step.\n   b) For each marked bar, start with its topmost block (smallest row index in that bar). From that block, extend diagonally up-left and up-right, one cell at a time, setting each empty cell (value 0) to the bar’s color, stopping before the first non-zero cell or the grid edge. Do not change any non-zero cell you encounter.\n   c) Repeat 2b for the next block in the same bar going downward (increasing row index), until all blocks in that bar have been processed. Do not overwrite cells already colored in earlier steps.\n3) Process vertical bars that lie along the left or right wall:\n   a) For column 1 and for the last column, for each maximal run of consecutive non-zero cells in that column, mark it as one vertical bar for this step.\n   b) For each marked bar, perform a flood fill on empty cells (value 0) that are 4-directionally adjacent (up, down, left, right) to any cell of the bar and connected through empty cells. Set all such reached empty cells to the bar’s color. Do not change any non-zero cell.\n4) Output the resulting grid.", "variations": ["1) Scan the wall-facing edge and identify all vertical bars that protrude away from the wall.\n2) For each protruding bar, start at its highest cell and cast rays along both diagonals, stopping each ray when it meets any block.\n3) Continue this process downward for each subsequent cell in the same bar, ensuring no diagonal overwrites or crosses previously established extensions.\n4) For vertical bars that remain flush against the wall, locate their orthogonally adjacent empty regions and flood them with the bar’s color without crossing any blocks.\n5) Return this grid", "1) Traverse columns touching the wall and classify each continuous vertical run as either extending outward or lying flat along the wall.\n2) For every extending bar, take the uppermost block and grow diagonal paths in both directions, halting growth the instant another block is encountered.\n3) Repeat the diagonal growth for each lower block in that bar, preserving all earlier diagonal placements and respecting existing blocks as boundaries.\n4) For bars lying flat along the wall, perform a region fill on all adjacent zero-valued cells, using the color of the bar and preventing the fill from passing through blocks.\n5) Return this grid", "1) From the wall side, detect vertical bars and separate them into two groups: those that jut outward and those aligned with the wall.\n2) For each outward bar, begin at the top block and emit diagonal beams in both directions until each beam contacts a blocking cell, then stop.\n3) Move to the next block down within the same bar and repeat the beam emission, honoring previously set diagonals and any obstructing blocks.\n4) For each wall-aligned bar, identify contiguous empty areas directly adjacent to it and color those areas with the bar’s color, ensuring blocks form hard boundaries for the coloring.\n5) Return this grid"], "llm_error": null, "all_test_hashes": ["67f68c8e"], "timestamp": 1758241435.384947}
{"task_id": "1190e5a7", "split": "training", "test_index": 0, "output": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1]], "output_hash": "d99c9990", "output_sha1": "1bbc7c38e4f0df5feaaa1eaad627dee8d2a339c5", "ok": false, "insts": ["1) You will se an input with a grid created by verticle horziontal lines. \n2) FInd the color of the filling for the grid.\n3) Create an output grids using the number of openings rowise and column wise in the input, and color them using the color from step 2. \n4) We are essentially contracting each sub grid to 1 block, and taking the dividers out, and keeping the color of trhe sub grids(they are the saem in the case)"], "insts_text": "1) You will se an input with a grid created by verticle horziontal lines. \n2) FInd the color of the filling for the grid.\n3) Create an output grids using the number of openings rowise and column wise in the input, and color them using the color from step 2. \n4) We are essentially contracting each sub grid to 1 block, and taking the dividers out, and keeping the color of trhe sub grids(they are the saem in the case)", "nlp_program": "1) Identify the fill color used inside the rectangular openings (not the divider line color). Use this as the output color.\n2) Count the number of horizontal openings: from the top edge to the first horizontal divider is opening 1; between each pair of horizontal dividers is one opening; from the last horizontal divider to the bottom edge is the last opening. This count is the number of output rows.\n3) Count the number of vertical openings: from the left edge to the first vertical divider is opening 1; between each pair of vertical dividers is one opening; from the last vertical divider to the right edge is the last opening. This count is the number of output columns.\n4) Create an output grid with the counted number of rows and the counted number of columns.\n5) Set every cell in the output grid to the fill color from step 1.", "variations": ["1) Detect all vertical and horizontal divider lines that form the grid compartments in the input.\n2) Identify the uniform fill color used inside the compartments.\n3) Count the number of compartment spans between dividers along the rows and along the columns.\n4) Create a compact output grid whose height equals the number of row spans and whose width equals the number of column spans.\n5) Fill every cell of this output grid with the identified color, with no dividers.\n\n1) Treat divider lines as walls and find all enclosed compartments via region detection.\n2) Confirm the common interior color shared by all compartments.\n3) Determine the layout by counting how many compartments exist per row and per column in their original arrangement.\n4) Produce an output grid with matching row and column counts, collapsing each compartment to a single cell.\n5) Color all cells with the common interior color and omit any walls.\n\n1) Scan each row and column to find transitions from divider to fill to divider, recording the number of filled intervals per row and per column.\n2) Sample any filled interval to obtain the uniform fill color.\n3) Construct an output array sized to the counted number of filled intervals vertically and horizontally.\n4) Populate every position in this array with the sampled color, eliminating all divider structure."], "llm_error": null, "all_test_hashes": ["404c5437"], "timestamp": 1758241600.3236756}
{"task_id": "10fcaaa3", "split": "training", "test_index": 0, "output": [[0, 3, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 3, 0], [0, 0, 0, 0, 0], [0, 3, 0, 0, 0]], "output_hash": "5469a6ad", "output_sha1": "559910fff7eee91eddc77b2e6e34277f8c38b579", "ok": false, "insts": ["1) Take the input grid, for each block color the adjacent diagonal blocks with 8. \n3 Now take this grid and copy it once to the right, once to the bottom and once the the bottom right(so a 2 by 2 super grid(with each section being the original dim of the input grid))\n4) So we added diagonals for the blocks, then took the resulting grid and repeated it across the rows and cols dims once."], "insts_text": "1) Take the input grid, for each block color the adjacent diagonal blocks with 8. \n3 Now take this grid and copy it once to the right, once to the bottom and once the the bottom right(so a 2 by 2 super grid(with each section being the original dim of the input grid))\n4) So we added diagonals for the blocks, then took the resulting grid and repeated it across the rows and cols dims once.", "nlp_program": "1. For each cell that contains a block, do steps 2–5.\n2. If there is a cell one row up and one column left, set that cell to value 8.\n3. If there is a cell one row up and one column right, set that cell to value 8.\n4. If there is a cell one row down and one column left, set that cell to value 8.\n5. If there is a cell one row down and one column right, set that cell to value 8.\n6. Make a 2 by 2 super grid, each quadrant the same size as the processed grid.\n7. Place the processed grid in the top-left quadrant.\n8. Copy the processed grid into the top-right quadrant.\n9. Copy the processed grid into the bottom-left quadrant.\n10. Copy the processed grid into the bottom-right quadrant.", "variations": ["1) Make a duplicate of the input grid as a working layer. 2) For every filled cell in the original, paint 8 on the four diagonal neighbors in the working layer (if within bounds). 3) Combine the working layer with the original so originals remain and diagonal 8s are added. 4) Place this combined grid into a 2 by 2 layout: top-left, top-right, bottom-left, bottom-right.", "1) Create four copies of the input grid shifted one cell in each diagonal direction (NW, NE, SW, SE). 2) In each shifted copy, convert all filled cells into 8s. 3) Overlay these four shifted copies onto the unshifted original so that diagonally adjacent positions become 8 while original cells stay unchanged. 4) Form a 2 by 2 supergrid by placing the result next to itself horizontally and vertically.", "1) For each block in the input, mark the cells at offsets (-1,-1), (-1,+1), (+1,-1), and (+1,+1) with 8, skipping any that fall outside the grid. 2) Keep the original blocks and add all the marked 8s. 3) Duplicate the finished grid to the right and below, and also fill the bottom-right quadrant, producing a 2 by 2 repetition of the result."], "llm_error": null, "all_test_hashes": ["baa32950"], "timestamp": 1758242037.7807899}
{"task_id": "11e1fe23", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output_hash": "5a28b460", "output_sha1": "981162ed285c7cde4d60d1d50fd6b9cb3e030818", "ok": false, "insts": ["1) You have three points in the grid.\n2) They form a triangle with all equal sides, with a right angle.\n3) Take the block at the right angle, get the block in the diagnocal between this block and the hypoteneus, but just above the hypoteneus and color it with the color of the block. Color the block on the hyp with 5. \n4) for the other two get teh block just before the the midpoint between them and color it the same color as the block. \n5) Essentially we color the midpoin of the hyp of the triangle with 5 and from this midpoint int he direction of each original block we color 1 block for each dir. Keep everything else the same in the output"], "insts_text": "1) You have three points in the grid.\n2) They form a triangle with all equal sides, with a right angle.\n3) Take the block at the right angle, get the block in the diagnocal between this block and the hypoteneus, but just above the hypoteneus and color it with the color of the block. Color the block on the hyp with 5. \n4) for the other two get teh block just before the the midpoint between them and color it the same color as the block. \n5) Essentially we color the midpoin of the hyp of the triangle with 5 and from this midpoint int he direction of each original block we color 1 block for each dir. Keep everything else the same in the output", "nlp_program": "1) Start with the three given colored cells. Keep all other cells unchanged.\n2) Choose the right-angle cell: the one that shares its row with one of the other two cells and shares its column with the remaining cell.\n3) The other two cells are the hypotenuse endpoints. From both of these cells, move 1 step diagonally toward each other at the same time (up-right/down-left or up-left/down-right as needed). Repeat this paired diagonal move until both moves would land on the same cell. Stop on that shared cell. This shared cell is the midpoint of the hypotenuse.\n4) Set the value of the midpoint cell (from step 3) to 5.\n5) From the midpoint cell, move 1 step diagonally toward the right-angle cell (up-left, up-right, down-left, or down-right, matching the direction from the midpoint to the right-angle cell). Color this cell with the color of the right-angle cell.\n6) From the midpoint cell, move 1 step diagonally toward each hypotenuse endpoint (two directions along the hypotenuse). For each direction, color that cell with the color of the corresponding hypotenuse endpoint.\n7) Do not change any other cells.", "variations": ["1) From the three points, find the pair with the largest distance; that pair defines the hypotenuse, and the remaining point is the right-angle corner.\n2) Locate the midpoint of the hypotenuse segment.\n3) Color the hypotenuse midpoint with 5.\n4) From the midpoint, step one cell along the hypotenuse toward each endpoint; color each of those two cells with the color of its corresponding endpoint point.\n5) Do not alter any other cells.", "1) Identify the right triangle by checking which point is orthogonal to the other two; the two non-orthogonal points are the hypotenuse endpoints.\n2) Compute the average of the hypotenuse endpoints to get the midpoint.\n3) Place a 5 at this midpoint.\n4) On the hypotenuse line, fill the two cells immediately adjacent to the midpoint: one toward each endpoint, using the color of that endpoint for its adjacent cell.\n5) Leave all remaining blocks unchanged.", "1) Determine the hypotenuse by selecting the two points that are not the right-angle vertex.\n2) Insert a 3-cell run centered on the hypotenuse’s midpoint, aligned with the hypotenuse.\n3) Set the center cell of this run to 5.\n4) Set the two flank cells of this run to match the colors of the nearer hypotenuse endpoints (each flank inherits the color of the endpoint it faces).\n5) Keep every other block as it was."], "llm_error": null, "all_test_hashes": ["39280179"], "timestamp": 1758242714.4464817}
{"task_id": "11dc524f", "split": "training", "test_index": 0, "output": [[7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 2, 7, 7], [7, 7, 7, 7, 5, 5, 7, 7, 7, 2, 2, 7, 7], [7, 7, 7, 7, 5, 5, 7, 7, 7, 2, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]], "output_hash": "1acfe4d3", "output_sha1": "43bca9b8e94e5d0c5b2e2405a1eee6ef3145ebd3", "ok": false, "insts": ["1) There are two objects a square and a nother shaped object. \n2) Move the other object so it touches the square(the shortest distance will always be either be vertical or horizontal straight). Then convert the square to the other shape, but preserve the color of the square.\n3) Output this shape"], "insts_text": "1) There are two objects a square and a nother shaped object. \n2) Move the other object so it touches the square(the shortest distance will always be either be vertical or horizontal straight). Then convert the square to the other shape, but preserve the color of the square.\n3) Output this shape", "nlp_program": "1) Use the two given objects: one square and one other shape.\n2) If both objects are in the same row: move the other shape horizontally, one cell at a time toward the square, until it touches the square edge-to-edge.\n3) Else (they are in the same column): move the other shape vertically, one cell at a time toward the square, until it touches the square edge-to-edge.\n4) At the square’s position: change the square’s shape to exactly match the other shape’s outline and size. Keep the color the same as the original square.\n5) Output the resulting shape.", "variations": ["1) Identify the square and the other-shaped object.\n2) Slide the square toward the other object along the shorter axis (horizontal or vertical) until they touch. Replace the square with a copy of the other object’s shape, keeping the square’s original color.\n3) Output the resulting shape.\n", "1) Locate the square and the non-square object.\n2) Move the non-square object straight along the shorter of the two axes to become adjacent to the square. Duplicate the non-square object’s silhouette and recolor it with the square’s color.\n3) Output this colored silhouette.\n", "1) Mark the square and the second object.\n2) Bring them together by translating both toward each other along the minimal horizontal/vertical route until they meet. Transform the square into the second object’s form while preserving the square’s color.\n3) Output the transformed shape."], "llm_error": null, "all_test_hashes": ["6436c0d3"], "timestamp": 1758242756.0194767}
{"task_id": "12422b43", "split": "training", "test_index": 0, "output": [[5, 0, 4, 4, 4, 0, 0], [5, 0, 0, 8, 0, 0, 0], [5, 0, 0, 6, 0, 0, 0], [0, 0, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]], "output_hash": "cd9496f1", "output_sha1": "66d9e2a8f4ed18371858b39ad04b1eb6904180b5", "ok": false, "insts": ["1) You have two objects 1 a no 5 colored vertical bar, and an object to the right. \n2) The vertical bar will be used to measure and cutoff the second object, cutoff any remaining remaining piece of the second object that is after the extent of the vertical bar. \n3) Use this cropped version to extend the 2nd object vertically, repeat until you hit a wall. (The first part is the full obj, only subsequent are the cropped version)\n4) Output this and cinlude the original vertical bar as well"], "insts_text": "1) You have two objects 1 a no 5 colored vertical bar, and an object to the right. \n2) The vertical bar will be used to measure and cutoff the second object, cutoff any remaining remaining piece of the second object that is after the extent of the vertical bar. \n3) Use this cropped version to extend the 2nd object vertically, repeat until you hit a wall. (The first part is the full obj, only subsequent are the cropped version)\n4) Output this and cinlude the original vertical bar as well", "nlp_program": "1) Identify the vertical bar on the left and the second object to its right. Do not move either.\n2) Measure the height of the vertical bar by counting its filled cells from its top cell to its bottom cell.\n3) Make one copy of the second object in memory. Do not place it yet.\n4) Crop the copy to keep only the top rows equal to the bar’s height. Keep the same columns as the original second object.\n5) Starting from the row immediately below the bottom row of the original second object, paste the cropped copy repeatedly in the same columns as the original second object, stacking downward without gaps, stopping before any part would go outside the bottom wall.\n6) Output the grid with the unchanged original second object, all pasted cropped copies below it, and the original vertical bar unchanged.", "variations": ["1) There is a vertical bar with five colors on the left, and a separate object to its right.\n2) Align the top edges; use the bar’s height as a ruler and cut off any portion of the right-hand object that extends below the bar’s bottom edge.\n3) Stack vertically starting with the full right-hand object, then repeat the cropped version directly beneath it until a boundary prevents further placement.\n4) Output the stacked result and retain the original colored vertical bar.\n\n1) You have a multicolored vertical bar and, to its right, another object.\n2) Slide the bar alongside the second object to mark the cutoff; erase any part of the second object that extends beyond the bar’s extent to form a trimmed template.\n3) Construct a column: place the unmodified second object first, then add repeated copies of the trimmed template upward or downward as space allows, stopping at the first wall.\n4) Produce the final layout with the original vertical bar kept in place.\n\n1) Treat the five-band vertical bar as a vertical clipping guide next to a second object on its right.\n2) Create a cropped variant of the second object by intersecting it with the bar’s vertical span and discarding any remainder beyond that span.\n3) Compose a vertical sequence with the full second object as the initial element, followed by repeated placements of the cropped variant in the same column until a boundary is encountered.\n4) Output the composition, including the original vertical bar."], "llm_error": null, "all_test_hashes": ["d96ecfa5"], "timestamp": 1758243077.4550586}
{"task_id": "12997ef3", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0], [0, 7, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output_hash": "3412c18f", "output_sha1": "25a7ef746ff2b0451170ce966f1bd24207469dfc", "ok": false, "insts": ["1) There is 1 object, and multiple small 1 piece blocks. The small blocks are either horizontally or vertically arranged. \n2) Take the large obj and based on number of smaller objs, create mroe large objs, and color them as such. Now eevry large object should correspond to a smaller obj in color. \n3) Order the large objs one after the other adjacently based on the small obj ordering\n4) Create the smallest bounding box, and output this grid. The final output grid should only have the large repeated obj with their different colors."], "insts_text": "1) There is 1 object, and multiple small 1 piece blocks. The small blocks are either horizontally or vertically arranged. \n2) Take the large obj and based on number of smaller objs, create mroe large objs, and color them as such. Now eevry large object should correspond to a smaller obj in color. \n3) Order the large objs one after the other adjacently based on the small obj ordering\n4) Create the smallest bounding box, and output this grid. The final output grid should only have the large repeated obj with their different colors.", "nlp_program": "1) On the input grid, select the only object made of more than 1 cell; call this the large object. Select all single-cell blocks; these are the small blocks.\n2) If all small blocks lie in one row, list their colors from left (smallest column index) to right (largest column index). If they lie in one column, list their colors from top (smallest row index) to bottom (largest row index).\n3) Start a new empty output grid. Do not copy anything else from the input grid.\n4) Make one full-shape copy of the large object for each listed color. For copy 1, recolor all its cells to color 1 in the list; for copy 2, recolor to color 2; continue until all copies are recolored.\n5) Place copy 1 with its top-left cell at output row 1, column 1.\n6) If the small blocks were in a row: for each next copy, place it directly to the right of the previous copy with no gap (the leftmost column of the new copy touches the column immediately after the rightmost column of the previous copy), aligning their top rows.\n7) If the small blocks were in a column: for each next copy, place it directly below the previous copy with no gap (the top row of the new copy touches the row immediately after the bottom row of the previous copy), aligning their left columns.\n8) Crop the output grid to the smallest bounding box that contains all placed copies by removing all-empty rows from top and bottom and all-empty columns from left and right.\n9) Output the cropped grid.", "variations": ["1) Identify a single template shape and a set of unit tiles that lie in a straight line horizontally or vertically.\n2) For each unit tile, create a duplicate of the template and recolor it to match that tile.\n3) Arrange all duplicates in a contiguous line that mirrors the unit tiles’ sequence (left-to-right or top-to-bottom).\n4) Crop to the smallest rectangle that encloses these duplicates and output only this arrangement.", "1) Detect one primary figure and several one-cell markers that are aligned either as a row or as a column.\n2) Generate one copy of the primary figure per marker and color each copy to match its marker’s color.\n3) Place the colored copies sequentially with no gaps, preserving the markers’ order along their alignment.\n4) Remove all other content, then trim to the tightest bounding box around the placed copies and return that grid.", "1) Observe a single main shape and a sequence of colored single cells positioned collinearly (horizontal or vertical).\n2) Read the sequence of single cells and spawn an equal number of main-shape replicas, painting each replica with the corresponding color.\n3) Lay out the painted replicas end-to-end in the same traversal order and along the same axis as the single-cell sequence.\n4) Enclose the layout in the minimal bounding box and output only this enclosed arrangement."], "llm_error": null, "all_test_hashes": ["1e6ecb96", "9ee37eee"], "timestamp": 1758243738.3073592}
{"task_id": "13713586", "split": "training", "test_index": 0, "output": [[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output_hash": "5e29192b", "output_sha1": "a2242ba2708d8c279fe07e601845115e201b78f8", "ok": false, "insts": ["1) There is a bar colored 5(horizontal or vertical and along a wall, let us call it bar A). And smaller parallel bars. \n2) Expand each  parallel bars, connecting it to the 1st wall. The color should be of the parallel bars, until the expansion reaches the bar A, then it stops(does not intersect with bar A)\n3) This visibility of the rectangles is arranged by size. The smallest is fully visible above all other rectangles(if there is an intersection with the ), the second above all except the  smallest etc. Essentially the depth of the filled rectangles is by the size. \n4) Return this output grid"], "insts_text": "1) There is a bar colored 5(horizontal or vertical and along a wall, let us call it bar A). And smaller parallel bars. \n2) Expand each  parallel bars, connecting it to the 1st wall. The color should be of the parallel bars, until the expansion reaches the bar A, then it stops(does not intersect with bar A)\n3) This visibility of the rectangles is arranged by size. The smallest is fully visible above all other rectangles(if there is an intersection with the ), the second above all except the  smallest etc. Essentially the depth of the filled rectangles is by the size. \n4) Return this output grid", "nlp_program": "1) Treat the grid edges as walls: top = row 1, bottom = last row, left = column 1, right = last column.\n2) Bar A: keep the existing contiguous bar of value 5 that lies along a wall (either all in one row touching row 1 or last row, or all in one column touching column 1 or last column). Do not change Bar A.\n3) Orientation: if all cells of Bar A share the same row, set orientation = horizontal. If all cells of Bar A share the same column, set orientation = vertical.\n4) Collect every other bar that is parallel to Bar A: each is a contiguous run of same-colored cells in a single row (if horizontal) or in a single column (if vertical). Include their existing cells; exclude Bar A.\n5) For each collected bar, define its target wall as the wall that Bar A lies along (row 1 or last row if horizontal; column 1 or last column if vertical).\n6) For each collected bar, form its filled rectangle using the bar’s own color:\n   - If orientation = horizontal: for every column covered by the bar, fill all cells from the bar’s row toward the target wall, stopping one cell before any cell of Bar A. Include the original bar cells.\n   - If orientation = vertical: for every row covered by the bar, fill all cells from the bar’s column toward the target wall, stopping one cell before any cell of Bar A. Include the original bar cells.\n7) Compute size of each filled rectangle as the number of grid cells it covers.\n8) Clear and redraw only the filled rectangles from step 6 and Bar A with this draw order: draw filled rectangles from largest size to smallest size; when sizes are equal, draw the one that appears first when scanning rows top-to-bottom and columns left-to-right; finally draw Bar A last so it stays intact.\n9) Return the resulting grid.", "variations": ["1) Place a primary bar A of color 5 flush with one boundary (horizontal or vertical). Add multiple shorter bars parallel to A.\n2) From each smaller bar, project a solid band straight toward the first wall. Keep the band the same color as its source bar, but halt the projection immediately when it would touch bar A (do not cross A).\n3) Order the visual stacking by size: the smallest projected rectangle is on top of all others, the next smallest above all except the smallest, and so on.\n4) Output the resulting grid.", "1) Establish a blocker bar A of color value 5 along one edge (either as a horizontal top/bottom edge bar or a vertical left/right edge bar). Place several shorter, parallel bars elsewhere.\n2) For every shorter bar, extend a rectangular strip in the direction of the first wall so that it would connect to that wall, using the bar’s own color; if this extension encounters bar A, stop just before A so they never intersect.\n3) Resolve overlaps by ranking rectangles from smallest to largest: smaller areas render above larger ones in that order.\n4) Return the composed grid.", "1) Create a dominant edge-aligned bar A (color 5), oriented horizontally or vertically, and distribute additional parallel bars of lesser length.\n2) Grow each lesser bar into a filled rectangle aimed at the first wall, preserving the original bar’s color; the growth is clipped by bar A so that it never crosses A and terminates upon reaching it.\n3) Apply depth by size: the minimal rectangle is fully visible over all others, the next minimal is above all but the smallest, continuing up to the largest at the bottom.\n4) Produce the final grid output."], "llm_error": null, "all_test_hashes": ["d91ced7c"], "timestamp": 1758250908.2482183}
{"task_id": "137eaa0f", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 5, 0, 0], [4, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0], [0, 5, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0]], "output_hash": "91fcddd3", "output_sha1": "3953aba8b37cf553847f0c89153fd5485deb65e6", "ok": false, "insts": ["1) You see subsets of a 3 by 3, each subset with the center intact, colored 5\n2) Create a output grid 3 by 3,\n3) For each object in the input take it and match the center 5 color to the center of the output grid(move the object to that position), Essentially translate the obj so that it center is in the correct positions,(the centers will overlap for all objs)\n4) If there are empty spaces in the 3 by 3 grid leave them colored 0."], "insts_text": "1) You see subsets of a 3 by 3, each subset with the center intact, colored 5\n2) Create a output grid 3 by 3,\n3) For each object in the input take it and match the center 5 color to the center of the output grid(move the object to that position), Essentially translate the obj so that it center is in the correct positions,(the centers will overlap for all objs)\n4) If there are empty spaces in the 3 by 3 grid leave them colored 0.", "nlp_program": "1) Make a 3x3 output grid. Set all cells (rows 1-3, columns 1-3) to value 0.\n2) For each input object, process them in the order given.\n3) For the current object: place its center cell (value 5) onto output row 2, column 2. Then, for every cell of this object that has a value other than 0, copy that exact value to the output cell at the same row/column offset from row 2, column 2 as it has from the object’s center.\n4) If a copied cell lands on an output cell that already has a value, replace it with the most recently copied value. Leave any output cells not written by any object as value 0.", "variations": ["1) Start with a 3 by 3 output grid filled with 0s, and set its center to 5\n2) For each input subset, locate its cell colored 5 and treat this as the anchor\n3) For every non-zero cell in the subset, compute its offset from the anchor and paint that offset position relative to the center in the output\n4) If multiple subsets paint the same output cell, keep any non-zero color (they should agree)", "1) For each input subset, translate it so that its 5 is centered on a 3 by 3 canvas\n2) Create a 3 by 3 output grid and overlay all translated canvases in any order\n3) Use a “last non-zero wins” rule while compositing, and force the center to 5 at the end\n4) Leave any cells never painted by any subset as 0", "1) Consider the 3 by 3 as offsets around a center; define the center as offset (0,0) with color 5\n2) For each offset position, collect the colors found at that same offset from the 5 across all input subsets\n3) Assign the output center to 5, and for every other offset choose a non-zero color if any were observed; otherwise set it to 0\n4) If multiple non-zero colors are observed for the same offset, choose the most frequent or use a fixed tie-breaker"], "llm_error": null, "all_test_hashes": ["38399484"], "timestamp": 1758252190.0048993}
{"task_id": "137f0df0", "split": "training", "test_index": 0, "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 0, 0, 5, 5, 0, 5, 5], [0, 5, 5, 0, 0, 5, 5, 0, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 0, 0, 5, 5, 0, 5, 5], [0, 5, 5, 0, 0, 5, 5, 0, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 0, 0, 5, 5, 0, 5, 5], [0, 5, 5, 0, 0, 5, 5, 0, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output_hash": "d5585e70", "output_sha1": "0818278b117e0249ccaf28e59b93d28137391c71", "ok": false, "insts": ["1) There are ordered blocks of color 5 in the input,  bound the blocks using a minimal bounding box. \n2) In this minimal bounding box fill the inside areas with the color 2. \n3) Thus we have bocks colored 5 and the area between them, colored 2, extend the area between them either horizontally or vertically( essentially block extending horizontally or vertically) and expand the minimal box to the whole original size. \n4) The extension should be colored 1(the section outside of the minimal bounding grid)\n\n5) Now return the output grid(it has the same shape as the input grid), but the area between the blocks if filled and extended"], "insts_text": "1) There are ordered blocks of color 5 in the input,  bound the blocks using a minimal bounding box. \n2) In this minimal bounding box fill the inside areas with the color 2. \n3) Thus we have bocks colored 5 and the area between them, colored 2, extend the area between them either horizontally or vertically( essentially block extending horizontally or vertically) and expand the minimal box to the whole original size. \n4) The extension should be colored 1(the section outside of the minimal bounding grid)\n\n5) Now return the output grid(it has the same shape as the input grid), but the area between the blocks if filled and extended", "nlp_program": "1) Copy the input grid to the output grid.\n2) Scan the entire grid. Record: Top = smallest row index with value 5; Bottom = largest row index with value 5; Left = smallest column index with value 5; Right = largest column index with value 5.\n3) For all cells with row Top to Bottom and column Left to Right: if the value is not 5, set it to 2.\n4) Perform exactly one extension:\n   4a) Horizontal extension: For each row r from Top to Bottom, set columns 1 to (Left-1) to 1 and columns (Right+1) to last column to 1.\n   OR\n   4b) Vertical extension: For each column c from Left to Right, set rows 1 to (Top-1) to 1 and rows (Bottom+1) to last row to 1.\n5) Return the output grid (same shape as the input).", "variations": ["1) Locate all cells colored 5 and crop the grid to their minimal bounding rectangle.\n2) Inside this cropped rectangle, perform a flood-fill of the empty spaces between 5s with color 2, stopping at any 5 borders.\n3) Choose a single direction (horizontal if the box is wider, vertical if taller) and extend the filled 2-region across the box in that direction until it spans between the 5 blocks.\n4) Place the rectangle back into the original grid size, setting every cell outside the cropped rectangle to color 1.\n5) Return the full-sized grid with 5s intact, the spaces between them filled and directionally extended by 2, and all out-of-box areas colored 1.", "1) Identify every cluster of color 5 and determine the smallest axis-aligned rectangle that contains all of them.\n2) Within this rectangle, for each line perpendicular to the chosen direction (pick horizontal if it connects more separate 5 clusters than vertical, otherwise vertical), fill the gaps between the first and last 5 encountered on that line with color 2.\n3) Propagate the filled 2-region along the chosen direction until the area between the 5 clusters forms a continuous band.\n4) Expand back to the original grid dimensions, painting all cells outside the rectangle as color 1.\n5) Output the grid where 5s remain, the interstitial region inside the rectangle is filled and extended with 2, and the exterior is 1.", "1) Collect all positions of color 5 and compute their tightest bounding box.\n2) Inside this box, apply a one-dimensional growth of the 5 regions either horizontally or vertically (choose the axis that requires fewer steps) until distinct 5 regions meet.\n3) Mark every cell that lies between the original 5 boundaries within the merged region as color 2, keeping the 5 cells unchanged.\n4) Restore the box to the original grid size, coloring everything outside the box as 1.\n5) Produce the final grid with 5 blocks preserved, the area between them filled/extended with 2, and the outside area set to 1."], "llm_error": null, "all_test_hashes": ["45fde4c0"], "timestamp": 1758252927.9071763}
{"task_id": "13f06aa5", "split": "training", "test_index": 0, "output": [[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 1, 2, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4], [4, 4, 2, 2, 4, 4, 4, 4, 4, 4, 4, 2, 2, 4, 4, 4, 4], [4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4, 2, 5, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 2, 2, 8, 2, 2, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]], "output_hash": "a30d51fc", "output_sha1": "a8ff8ade01c718c450e9ec112cea06c5f8b25e0d", "ok": false, "insts": ["1) You see a space space ship like objects with unifrom color except a block that is different. \n2) For each distinct object in the spaceship take the direction it is facing and place a copy of the 1 block, a block ahead(there is 1 empty block between the original block and the copied), and do this alternating, until you hit a wall, in which case the whole wall is colored with the border color of the same color as the block. \n3) If the newly made borders at the a wall intersect with borders of another wall, mark the intersection with color 0\n4) Do this for each spaceship."], "insts_text": "1) You see a space space ship like objects with unifrom color except a block that is different. \n2) For each distinct object in the spaceship take the direction it is facing and place a copy of the 1 block, a block ahead(there is 1 empty block between the original block and the copied), and do this alternating, until you hit a wall, in which case the whole wall is colored with the border color of the same color as the block. \n3) If the newly made borders at the a wall intersect with borders of another wall, mark the intersection with color 0\n4) Do this for each spaceship.", "nlp_program": "1) For each spaceship object (given), do steps 2–6.\n2) Note the spaceship’s uniform color (main color). Note the location (row, column) and color of its single different cell (special cell).\n3) Using the spaceship’s given facing direction, start at the special cell. Move 2 cells forward in that direction. Color that landing cell with the special cell’s color. Repeat: move 2 more cells forward and color the landing cell with the special cell’s color. Stop when the next 2-cell move would go past the grid edge.\n4) If the facing direction is up and you must stop, color every cell in row 1 with the spaceship’s main color.\n5) If the facing direction is down and you must stop, color every cell in the last row with the spaceship’s main color. If left, color every cell in column 1 with the spaceship’s main color. If right, color every cell in the last column with the spaceship’s main color.\n6) While coloring any edge cell in steps 4–5: if that cell already has a different non-zero color from a previous edge coloring, set that edge cell to color 0.", "variations": ["1) Identify each spaceship-shaped object with a single standout block and determine its facing direction.\n2) From the standout block, cast a ray in the facing direction and place copies of the block on every second cell along the ray (leaving a one-cell gap before the first copy), stopping just before any wall.\n3) Upon encountering a wall in that direction, color the entire wall with the border color matching the standout block’s color.\n4) After processing all spaceships, wherever colored walls from different ships meet, set the intersection cells to color 0.\n\n1) Locate every spaceship-like object comprised of a uniform body and one distinct block; infer the object’s forward direction.\n2) First find the wall reached by moving forward from the distinct block; color that entire wall using the border color corresponding to the block’s color.\n3) Starting from the wall and moving back toward the object, place copies of the distinct block on every second cell, stopping when a one-cell gap remains between the last copy and the original block.\n4) If any cells on a wall receive border colors from more than one ship, overwrite those intersection cells with color 0.\n\n1) For each spaceship with one differently colored block, read its facing direction.\n2) Generate a repeating pattern along that direction by iterating k = 1, 2, 3, ...: at position 2k steps ahead of the distinct block, place a copy; stop the sequence when the next placement would pass a wall.\n3) When a wall bounds the sequence, fill that entire wall with the border color that matches the distinct block’s color.\n4) While painting walls, if a wall cell already bears a different ship’s border color, mark that cell as color 0 to denote an intersection."], "llm_error": null, "all_test_hashes": ["f9d6b4e9"], "timestamp": 1758253975.7802324}
{"task_id": "140c817e", "split": "training", "test_index": 0, "output": [[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 1, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1]], "output_hash": "5ddc76c0", "output_sha1": "ee25ff4a73caf269b1dd4ba3e55caf6866f151f8", "ok": false, "insts": ["1) You see a uniform background, with isolated blocks colored 0\n2) Take the blocks colored 0 and make them colored 2.\n3) Around the block points create a 3 colored 3 by 3 square(keep the middle block color 2)\n3) Then extend the blocks vertically and horizontally with zero colored lines. For each unique individual block do this, until you reach a wall. Note the lines will intersect the 3 by 3 boxes the intersection should be 0 colored."], "insts_text": "1) You see a uniform background, with isolated blocks colored 0\n2) Take the blocks colored 0 and make them colored 2.\n3) Around the block points create a 3 colored 3 by 3 square(keep the middle block color 2)\n3) Then extend the blocks vertically and horizontally with zero colored lines. For each unique individual block do this, until you reach a wall. Note the lines will intersect the 3 by 3 boxes the intersection should be 0 colored.", "nlp_program": "1) Change every cell with value 0 to value 2.\n2) For each cell with value 2, set its 8 immediate neighbors (up, down, left, right, and the four diagonals) to value 3. Do not change the center cell.\n3) For each such center cell (currently value 2), draw four lines of value 0 that overwrite any existing values:\n   - Up: from the center, move one cell up at a time in the same column until the grid edge; set each visited cell to 0.\n   - Down: from the center, move one cell down at a time until the grid edge; set each visited cell to 0.\n   - Left: from the center, move one cell left at a time until the grid edge; set each visited cell to 0.\n   - Right: from the center, move one cell right at a time until the grid edge; set each visited cell to 0.\n4) Where these 0-value lines pass through any 3x3 squares from step 2 (including the center cell and the cells in the same row and column within the 3x3), keep those intersection cells as 0.", "variations": ["1) Start with a uniform background containing isolated single cells colored 0.\n2) For each such cell, recolor it to 2.\n3) Draw a 3 by 3 ring of color 3 centered on the 2, leaving the center as 2.\n4) From the center, project horizontal and vertical lines colored 0 outward until the boundary; where these lines cross the 3 by 3 ring, keep those crossing cells 0.", "1) Detect every solitary 0 on the plain background.\n2) From each detected position, lay down four straight rays (up, down, left, right) of color 0 until reaching the border.\n3) Around the origin of each ray set, place a 3 by 3 square frame of color 3, preserving the center as 2.\n4) Ensure any ray cells that pass through the frame remain 0, even if they overlap the 3 color; finally confirm the central cell is 2.", "1) Identify each individual 0 block on the uniform canvas.\n2) Place a 3 by 3 colored 3 square centered on each, but do not fill the center.\n3) Convert the center cell to color 2.\n4) From the center, extend lines of color 0 in the four cardinal directions until walls; any parts of these lines that pass through the 3 by 3 square should remain 0, leaving the frame otherwise 3."], "llm_error": null, "all_test_hashes": ["e084adbf"], "timestamp": 1758254186.072037}
